#!/usr/bin/perl -w

# Copyright (c) 2006 by Jeff Ratcliffe (ra28145 at users dot sourceforge dot net)
# This script is released under the GPL license.  Please
# see the included LICENSE file for details.

# To do
# 0. Fix Failed to load RGB data from TIFF file: libpixbuf-tiff: Read error on strip 134; got 5190 bytes, expected 7130
#    Add renumber - menu item from 1..n
#    Add status line at bottom with messages like "filename saved"
#    Add Gnome menu
#    Save scan & window (maximise/size) settings
#    Work out how to resize scan window when options change
# 1. Reorder pages (DND)
# 2. Rotate
# 3. Add icons for import, save tiff, save pdf, quit, etc.
# 4. Add view menu matching zoom buttons
# 5. Get documentation up to scratch
# 6. Tooltips
# 7. Translations
# 8. Progress meter for scans and imports.
# 9. Hide windows rather than destroying them & other speedups

use strict;
use IPC::Open3;
use IO::Handle;
use Gtk2 -init;
use Gtk2::SimpleList;
use Cwd;                             # To obtain current working directory
use File::Temp qw/tempfile tempdir/; # To create temporary files

use constant TRUE  => 1;
use constant FALSE => 0;

my $program = "gscan2pdf";
my $version = "0.6.3";

# Standard paper sizes
my @paper = qw/A4 Letter/;
my @x = ( 210, 215.9 );
my @y = ( 297, 279 );

my $test = FALSE;

$test = $ARGV[1] if ($ARGV[0] eq "--test");

if (check_utils()) {
 print "$program requires the libtiff library.\nPlease install it.\n";
 exit 1;
}

# This is the GtkItemFactoryEntry structure used to generate new menus.
# Item 1: The menu path. The letter after the underscore indicates an
#         accelerator key once the menu is open.
# Item 2: The accelerator key for the entry
# Item 3: The callback function.
# Item 4: The callback action.  This changes the parameters with
#         which the function is called.  The default is 0.
# Item 5: The item type, used to define what kind of an item it is.
#         Here are the possible values:
#          NULL               -> "<Item>"
#          ""                 -> "<Item>"
#          "<Title>"          -> create a title item
#          "<Item>"           -> create a simple item
#          "<CheckItem>"      -> create a check item
#          "<ToggleItem>"     -> create a toggle item
#          "<RadioItem>"      -> create a radio item
#          <path>             -> path of a radio item to link against
#          "<Separator>"      -> create a separator
#          "<Branch>"         -> create an item to hold sub items (optional)
#          "<LastBranch>"     -> create a right justified branch 

my @menu_items = ( { path        => '/_File',
		     item_type   => '<Branch>' },
		   { path        => '/File/_New',
		     accelerator => '<control>n',
		     callback    => \&do_new },
		   { path        => '/File/_Import',
		     accelerator => '<control>i',
		     callback    => \&do_import },
		   { path        => '/File/Sca_n',
		     callback    => \&scan_dialog },
		   { path        => '/File/_Save PDF',
		     accelerator => '<control>s',
		     callback    => \&do_PDF },
		   { path        => '/File/Save _TIFF',
		     accelerator => '<control>t',
		     callback    => \&do_TIFF },
		   { path        => '/File/sep1',
		     item_type   => '<Separator>' },
		   { path        => '/File/_Quit',
		     accelerator => '<control>q',
		     callback    => sub { Gtk2 -> main_quit; } },

		   { path        => '/_Edit',
		     item_type   => '<Branch>' },
		   { path        => '/Edit/_Delete',
		     accelerator => 'Delete',
		     callback    => \&do_delete },
		   { path        => '/Edit/Select _All',
		     accelerator => '<control>a',
		     callback    => \&do_select_all },

		   { path        => '/_Help',
		     item_type   => '<LastBranch>' },
		   { path        => '/_Help/About',
		     callback    => \&do_about } );

# Create the window
my $window = new Gtk2::Window ( 'toplevel' );
$window -> signal_connect ( 'destroy', sub { Gtk2 -> main_quit; } );
$window -> set_title ( "$program v$version" );
$window -> set_default_size (800, 600);
$window -> maximize;

# Pass the window a stock icon list
my @icon;
my $i = -1;
foreach my $size (qw/menu small-toolbar large-toolbar button dnd dialog/) {
 ++$i;
 $icon[$i] = $window -> render_icon ('gtk-print-preview', $size)
}
$window -> set_icon_list ( @icon );

my $main_vbox = new Gtk2::VBox ( FALSE, 1 );
$window -> add ( $main_vbox );

# Create the menu bar
my $menubar = create_menu_bar( $window );
$main_vbox -> pack_start( $menubar, FALSE, TRUE, 0 );

# Button bar
my $hboxb = Gtk2::HBox -> new;
$main_vbox -> pack_start ($hboxb, FALSE, FALSE, 0);
my $bbox = Gtk2::HButtonBox -> new;
$hboxb -> pack_start ($bbox, FALSE, FALSE, 0);

# Zoom to fullsize button
my $button1 = Gtk2::Button -> new_from_stock('gtk-zoom-100');
$button1 -> signal_connect(clicked => \&zoom_button);
$bbox -> add($button1);

# Zoom to fit button
my $buttonfit = Gtk2::Button -> new_from_stock('gtk-zoom-fit');
$buttonfit -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonfit);

# Zoom-in button
my $buttonin = Gtk2::Button -> new_from_stock('gtk-zoom-in');
$buttonin -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonin);

# Zoom-out button
my $buttonout = Gtk2::Button -> new_from_stock('gtk-zoom-out');
$buttonout -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonout);

# HPaned for thumbnails and detail view
my $hpaned = Gtk2::HPaned -> new;
$main_vbox -> pack_start($hpaned, TRUE, TRUE, 0);

# Thumbnail dimensions
my $widtht = 100;
my $heightt = 100;
$hpaned->set_position ($widtht);

# Scrolled window for thumbnails
my $scwin_thumbs = Gtk2::ScrolledWindow -> new;
$hpaned -> pack1 ($scwin_thumbs, TRUE, TRUE);
$scwin_thumbs -> set_policy ('automatic', 'automatic');

# define filename and i to be hidden
Gtk2::SimpleList -> add_column_type( 'filename',
                                     type => 'Glib::String',
                                     attr => 'hidden' );

# Set up a SimpleList, sorted by #2, which is hidden
my $slist = Gtk2::SimpleList -> new('#' => 'int',
                                   'Thumbnails' => 'pixbuf',
                                   'Filename' => 'filename');
$slist -> get_selection -> set_mode ('multiple');
$slist -> get_model -> set_sort_column_id (0, 'ascending');

# Set the page number to be editable
$slist -> set_column_editable (0, TRUE);

# Set-up the callback when the page number has been edited.
$slist -> get_model -> signal_connect('row-changed' => sub {

# turn off the signal whilst in the sub to prevent multiple calls.
# local $SIG{'row-changed'} = 'IGNORE';
#warn "in callback\n";

# check here that there an no double page numbers and renumber if needed.
 my $i = 1;
 while ($i <= $#{$slist -> {data}}) {
  if ($slist -> {data}[$i][0] == $slist -> {data}[$i-1][0]) {
   ++($slist -> {data}[$i][0]);
  };
  ++$i;
 }
});

$scwin_thumbs -> add_with_viewport($slist);

# Scrolled window for detail view
my $scwin_detail = Gtk2::ScrolledWindow -> new;
$hpaned -> pack2 ($scwin_detail, TRUE, TRUE);
$scwin_detail -> set_policy ('automatic', 'automatic');

# Globally define the $image variables for $scwin_detail
my $image;
my $scale;
my $src_pixbuf;
my $widthi;
my $heighti;

# Globally define the custom paper box.
my $hboxc;

# Set up call back for list selection to update detail view
$slist -> get_selection -> signal_connect(changed => sub {
 my @page = $slist -> get_selected_indices;

# Remove any image in the detail window
 if (defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
 }

# Display the new image
 if ($#page > -1) {

# Get dimensions for detail window
  my $widthd = $scwin_detail -> allocation -> width;
  my $heightd = $scwin_detail -> allocation -> height;

  $image = Gtk2::Image -> new;

# scalar needed for reasons I don't understand, but which have to do with
# converting the array to a scalar. Alternatively, it might be a bug.
  $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file (scalar($slist->{data}[$page[0]][2]));

# Get dimension for image
  $widthi = $src_pixbuf -> get_width;
  $heighti = $src_pixbuf -> get_height;

# Calculate scale factor to fit window, being conservative
  $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;

  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
});

# Note the current directory
my $cwd = getcwd;

# Create a temporary directory for scans
my $dir = tempdir;

$window -> show_all;
Gtk2 -> main;

# Remove temporary files (for some reason File::Temp wasn't doing its job here)
unlink <$dir/*>;
rmdir $dir;



### Subroutines

# Create the menu bar, initialize its menus, and return the menu bar.

sub create_menu_bar
{
 my ($window) = @_;

 my $accel_group = new Gtk2::AccelGroup;

 # This function initializes the item factory.
 # Param 1: The type of menu - can be 'Gtk2::MenuBar', 'Gtk2::Menu',
 #          or 'Gtk2::OptionMenu'.
 # Param 2: The path of the menu.
 # Param 3: The accelerator group.  The item factory sets up
 #          the accelerator table while generating menus.
 my $item_factory = new Gtk2::ItemFactory( 'Gtk2::MenuBar', '<main>',
                                                                 $accel_group );

 # This function generates the menu items. Pass the item factory,
 # the number of items in the array, the array itself, and any
 # callback data for the the menu items.
 $item_factory -> create_items( @menu_items );

 # Attach the new accelerator group to the window.
 $window -> add_accel_group( $accel_group );

 # Finally, return the actual menu bar created by the item factory.
 #*menubar = gtk_item_factory_get_widget (item_factory, "<main>");
 return ( $item_factory -> get_widget( '<main>' ) );
}


# Zoom the detail window

sub zoom_button {
 my $button = $_[0];
 if (defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
  if ($button eq $button1) {
   $scale = 1;
  }
  elsif ($button eq $buttonin) {
   $scale *= 1.2;
  }
  elsif ($button eq $buttonout) {
   $scale /= 1.2;
  }
  else {
   my $widthd = $scwin_detail -> allocation -> width;
   my $heightd = $scwin_detail -> allocation -> height;
   $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;
  }
  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
}


# Zoom the image

sub zoom_pixbuf {
 my ($src, $dest, $scale) = @_;
 $src -> composite ($dest, 0, 0, $dest -> get_width,
                                 $dest -> get_height, 
                    0, 0, $scale, $scale, 'bilinear', 255);
}


# Deletes all scans after warning.

sub do_new {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'warning', 'ok-cancel',
                     "This will clear the list of scanned images.\n"
                     . "Do you want to continue?");
 if ($dialog -> run eq 'ok') {

# Remove any image in the detail window
  if ($image) {
   my $viewport = $image -> get_parent;
   $image -> destroy;
   $viewport -> destroy;
  }

# Depopulate the thumbnail list
  while ($#{$slist -> {data}} > -1) {
   pop @{$slist -> {data}};
  }
 }
 $dialog -> destroy;
}


# Throw up file selector and import selected file

sub do_import {

# cd back to cwd to get filename
 chdir $cwd;

 my $fileselection = Gtk2::FileSelection -> new("Import scan from file");
 $fileselection -> set_modal(TRUE);
 $fileselection -> set_select_multiple(TRUE);

# cd back to tempdir to import
  chdir $dir;

# callback for OK button
 my $fs_ok_button = $fileselection -> ok_button;
 $fs_ok_button -> signal_connect(clicked => sub {

# Get filename(s) for PDF
  my @filename = $fileselection -> get_selections;

  $fileselection -> destroy;

  foreach my $filename (@filename) {

# Check that the file really is a tiff
   my $output = `tiffinfo \"$filename\" 2>&1 1>/dev/null`;
   if ($output =~ /Not a TIFF file/) {
    my $dialog = Gtk2::MessageDialog -> new ($window,
                                            'destroy-with-parent',
                                            'error',
                                            'close',
                                            "Not a TIFF file");
    $dialog -> run;
    $dialog -> destroy;
   }
   else {

# Split the tiff into its pages and import them individually
    system("tiffsplit \"$filename\"");
    my @pages = <x???.tif>;
    foreach (@pages) {
     import_scan($_);
    }
   }

  }
 });

# callback for cancel button
 my $fs_cancel_b = $fileselection -> cancel_button;
 $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

 $fileselection -> show_all;
}


# Throw up file selector and save selected pages as PDF under given name.

sub do_PDF {

# PDF pop-up window
 my $window = Gtk2::Window -> new;
 $window -> set_border_width(10);
 $window -> set_title ('Save as PDF');
 $window -> signal_connect (delete_event => sub { $_[0] -> destroy; });

# VBox for window
 my $vbox = Gtk2::VBox -> new;
 $window -> add ($vbox);

# Frame for metadata
 my $framem = Gtk2::Frame -> new('Metadata');
 $vbox -> pack_start ($framem, TRUE, TRUE, 0);
 my $vboxm = Gtk2::VBox -> new;
 $vboxm -> set_border_width(6);
 $framem -> add ($vboxm);

# Date/time
 my $hboxe = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxe, TRUE, TRUE, 0);
 my $labele = Gtk2::Label -> new ("Date & Time");
 $hboxe -> pack_start ($labele, FALSE, FALSE, 0);
 my ($day, $month, $year) = (localtime())[3, 4, 5];
 $year += 1900;
 $month += 1;
 my $buttone = Gtk2::Button -> new("$year/$month/$day");
 $buttone -> signal_connect( clicked => sub {
  my $window = Gtk2::Window -> new;
  $window -> set_title ('Select Date' );
  $window->set_border_width(5);
  $window->signal_connect( 'destroy' => sub { $window -> destroy; } );
  $window->set_resizable(FALSE);

  my $vbox = Gtk2::VBox -> new;
  $window -> add($vbox);

  my $calendar = Gtk2::Calendar -> new;
  $vbox -> pack_start ($calendar, TRUE, TRUE, 0);

  $calendar -> signal_connect(day_selected_double_click => sub {
   ($year, $month, $day) = $calendar -> get_date();
   $month += 1;
   $buttone -> set_label ("$year/$month/$day");
   $window -> destroy;
  });

  $window -> show_all;
 } );
 $hboxe -> pack_end( $buttone, TRUE, TRUE, 0 );

# Document author
 my $hboxa = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxa, TRUE, TRUE, 0);
 my $labela = Gtk2::Label -> new ("Document author");
 $hboxa -> pack_start ($labela, FALSE, FALSE, 0);
 my $entrya = Gtk2::Entry -> new;
 $hboxa -> pack_end( $entrya, TRUE, TRUE, 0 );

# Title
 my $hboxt = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxt, TRUE, TRUE, 0);
 my $labelt = Gtk2::Label -> new ("Title");
 $hboxt -> pack_start ($labelt, FALSE, FALSE, 0);
 my $entryt = Gtk2::Entry -> new;
 $hboxt -> pack_end( $entryt, TRUE, TRUE, 0 );

# Subject
 my $hboxs = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxs, TRUE, TRUE, 0);
 my $labels = Gtk2::Label -> new ("Subject");
 $hboxs -> pack_start ($labels, FALSE, FALSE, 0);
 my $entrys = Gtk2::Entry -> new;
 $hboxs -> pack_end( $entrys, TRUE, TRUE, 0 );

# Keywords
 my $hboxk = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxk, TRUE, TRUE, 0);
 my $labelk = Gtk2::Label -> new ("Keywords");
 $hboxk -> pack_start ($labelk, FALSE, FALSE, 0);
 my $entryk = Gtk2::Entry -> new;
 $hboxk -> pack_end( $entryk, TRUE, TRUE, 0 );

# Frame for page range
 my $framep = Gtk2::Frame -> new('Page range');
 $vbox -> pack_start ($framep, TRUE, TRUE, 0);
 my $vboxp = Gtk2::VBox -> new;
 $vboxp -> set_border_width(6);
 $framep -> add ($vboxp);

#the first radio button has to set the group,
#which is undef for the first button
# All button
 my $buttona = Gtk2::RadioButton -> new(undef, "All");
 $vboxp -> pack_start($buttona, TRUE, TRUE, 0);
 my @group = $buttona -> get_group;

# Current button
 my $buttonc = Gtk2::RadioButton -> new(@group, "Current");
 $vboxp -> pack_start($buttonc, TRUE, TRUE, 0);

# Selected button
 my $buttons = Gtk2::RadioButton -> new(@group, "Selected");
 $vboxp -> pack_start($buttons, TRUE, TRUE, 0);
 $buttons -> set_active(TRUE);

# Pages button
# my $hboxp = Gtk2::HBox -> new;
# $vboxp -> pack_start($hboxp, TRUE, TRUE, 0);
# my $buttonp = Gtk2::RadioButton -> new(@group, "Pages:");
# $hboxp -> pack_start($buttonp, FALSE, FALSE, 0);

# Page List
# my $entryp = Gtk2::Entry -> new;
# $entryp -> signal_connect ('insert-text' => sub {
#  my ($widget, $string, $len, $position) = @_;
#  if ($string !~ /^[0-9]+$/) { # Only add numbers
#   $entryp -> signal_stop_emission_by_name ('insert-text');
#   $buttonp -> set_active(TRUE); # Set the radiobutton active
#  }
#  () # this callback must return either 2 or 0 items.
# });
# $hboxp -> pack_end ($entryp, FALSE, FALSE, 0);

# HBox for filename
 my $hboxf = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxf, TRUE, TRUE, 0);

# Filename
 my $labelf = Gtk2::Label -> new ("Filename");
 $hboxf -> pack_start ($labelf, TRUE, TRUE, 0);
 my $entryf = Gtk2::Entry -> new;
 my $filename = "$cwd/out.pdf";
 $entryf -> set_text($filename);
 $hboxf -> add ($entryf);
 my $bbutton = Gtk2::Button -> new('Browse');
 $hboxf -> pack_end( $bbutton, TRUE, TRUE, 0 );
 $bbutton -> signal_connect (clicked => sub {

# cd back to cwd to save
  chdir $cwd;

# Set up file selector
  my $fileselection = Gtk2::FileSelection -> new("PDF filename");
  $fileselection -> set_modal(TRUE);
  my $fs_ok_button = $fileselection -> ok_button;

# callback for OK button
  $fs_ok_button -> signal_connect(clicked => sub {
   $filename = $fileselection -> get_filename;
   $entryf -> set_text($filename);
   $fileselection -> destroy;
  });

# callback for cancel button
  my $fs_cancel_b = $fileselection -> cancel_button;
  $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

  $fileselection -> show_all;

# cd back to tempdir
  chdir $dir;
 } );

# HBox for buttons
 my $hboxb = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Save button
 my $sbutton = Gtk2::Button -> new('Save');
 $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
 $sbutton -> signal_connect (clicked => sub {

# Get filename
  $filename = $entryf -> get_text;

# fill $pagelist with filenames depending on which radiobutton is active
  my $n;
  my $pagelist;
  if ($buttona -> get_active) {
   $n = $#{$slist -> {data}};
   $pagelist = $slist -> {data}[0][2];
   my $i = 1;
   while ($i <= $#{$slist -> {data}}) {
    $pagelist = $pagelist." ".$slist -> {data}[$i][2];
    ++$i;
   }
  }
  elsif ($buttonc -> get_active) {
   $n = 1;
   my @page = $slist -> get_selected_indices;
   $pagelist = $slist -> {data}[$page[0]][2];
  }
  elsif ($buttons -> get_active) {
   my @page = $slist -> get_selected_indices;
   $n = $#page;
   $pagelist = $slist -> {data}[$page[0]][2];
   my $i = 1;
   while ($i <= $#page) {
    $pagelist = $pagelist." ".$slist -> {data}[$page[$i]][2];
    ++$i;
   }
  }

# Set options and metadata
  my $options = " -z -o \"$filename\""
              . sprintf (" -e %4i%02i%02i", $year, $month, $day)
              . " -c \"$program v$version\""
              . " -a \"" . $entrya -> get_text . "\""
              . " -t \"" . $entryt -> get_text . "\""
              . " -s \"" . $entrys -> get_text . "\""
              . " -k \"" . $entryk -> get_text . "\"";

# call tiff2pdf and/or tiffcp according to the number of pages
  if ($n > 0) {
   system ("tiffcp $pagelist \"$filename.tif\"");
   system ("tiff2pdf $options \"$filename.tif\"");
   unlink ("$filename.tif"); # delete the temporary tiff
  }
  else {
   system ("tiff2pdf $options $pagelist");
  }
  
  $window -> destroy;
 } );

# Cancel button
 my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
 $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
 $cbutton -> signal_connect( clicked => sub { $window -> destroy; } );

 $window -> show_all;
}


# Throw up file selector and save selected pages as PDF under given name.

sub do_TIFF {

# PDF pop-up window
 my $window = Gtk2::Window -> new;
 $window -> set_border_width(10);
 $window -> set_title ('Save as TIFF');
 $window -> signal_connect (delete_event => sub { $_[0] -> destroy; });

# VBox for window
 my $vbox = Gtk2::VBox -> new;
 $window -> add ($vbox);

# Frame for page range
 my $framep = Gtk2::Frame -> new('Page range');
 $vbox -> pack_start ($framep, TRUE, TRUE, 0);
 my $vboxp = Gtk2::VBox -> new;
 $vboxp -> set_border_width(6);
 $framep -> add ($vboxp);

#the first radio button has to set the group,
#which is undef for the first button
# All button
 my $buttona = Gtk2::RadioButton -> new(undef, "All");
 $vboxp -> pack_start($buttona, TRUE, TRUE, 0);
 my @group = $buttona -> get_group;

# Current button
 my $buttonc = Gtk2::RadioButton -> new(@group, "Current");
 $vboxp -> pack_start($buttonc, TRUE, TRUE, 0);

# Selected button
 my $buttons = Gtk2::RadioButton -> new(@group, "Selected");
 $vboxp -> pack_start($buttons, TRUE, TRUE, 0);
 $buttons -> set_active(TRUE);

# HBox for filename
 my $hboxf = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxf, TRUE, TRUE, 0);

# Filename
 my $labelf = Gtk2::Label -> new ("Filename");
 $hboxf -> pack_start ($labelf, TRUE, TRUE, 0);
 my $entryf = Gtk2::Entry -> new;
 my $filename = "$cwd/out.tif";
 $entryf -> set_text($filename);
 $hboxf -> add ($entryf);
 my $bbutton = Gtk2::Button -> new('Browse');
 $hboxf -> pack_end( $bbutton, TRUE, TRUE, 0 );
 $bbutton -> signal_connect (clicked => sub {

# cd back to cwd to save
  chdir $cwd;

# Set up file selector
  my $fileselection = Gtk2::FileSelection -> new("TIFF filename");
  $fileselection -> set_modal(TRUE);
  my $fs_ok_button = $fileselection -> ok_button;

# callback for OK button
  $fs_ok_button -> signal_connect(clicked => sub {
   $filename = $fileselection -> get_filename;
   $entryf -> set_text($filename);
   $fileselection -> destroy;
  });

# callback for cancel button
  my $fs_cancel_b = $fileselection -> cancel_button;
  $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

  $fileselection -> show_all;

# cd back to tempdir
  chdir $dir;
 } );

# HBox for buttons
 my $hboxb = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Save button
 my $sbutton = Gtk2::Button -> new('Save');
 $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
 $sbutton -> signal_connect (clicked => sub {

# Get filename
  $filename = $entryf -> get_text;

# fill $pagelist with filenames depending on which radiobutton is active
  my $n;
  my $pagelist;
  if ($buttona -> get_active) {
   $n = $#{$slist -> {data}};
   $pagelist = $slist -> {data}[0][2];
   my $i = 1;
   while ($i <= $#{$slist -> {data}}) {
    $pagelist = $pagelist." ".$slist -> {data}[$i][2];
    ++$i;
   }
  }
  elsif ($buttonc -> get_active) {
   $n = 1;
   my @page = $slist -> get_selected_indices;
   $pagelist = $slist -> {data}[$page[0]][2];
  }
  elsif ($buttons -> get_active) {
   my @page = $slist -> get_selected_indices;
   $n = $#page;
   $pagelist = $slist -> {data}[$page[0]][2];
   my $i = 1;
   while ($i <= $#page) {
    $pagelist = $pagelist." ".$slist -> {data}[$page[$i]][2];
    ++$i;
   }
  }

# Create the tiff
  system ("tiffcp $pagelist \"$filename\"");

  $window -> destroy;
 } );

# Cancel button
 my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
 $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
 $cbutton -> signal_connect( clicked => sub { $window -> destroy; } );

 $window -> show_all;
}


# Scan

sub scan_dialog {
 my $output = `scanimage --version 2>/dev/null`;
 if ($? ne 0) {
  my $dialog = Gtk2::MessageDialog -> new ($window,
                                          'destroy-with-parent',
                                          'error',
                                          'close',
                                          "scanimage not found");
  $dialog -> run;
  $dialog -> destroy;
  return 0;
 }
 my @output = `scanimage --list-devices 2>/dev/null`;
 if ($? eq 0) {
  if ($#output > 1 && $output[0] =~ /^\s$/ 
                   && $output[1] =~ /^No scanners were identified/
                   && ! $test) {
   my $dialog = Gtk2::MessageDialog -> new ($window,
                                           'destroy-with-parent',
                                           'error',
                                           'close',
                                           "No scanners found");
   $dialog -> run;
   $dialog -> destroy;
  }
  else {

# scan pop-up window
   my $window = Gtk2::Window -> new;
   $window -> set_border_width(10);
   $window -> set_title ('Scan Document');
   $window -> set_keep_above (TRUE);
#   $window -> set_modal (TRUE);
   $window -> signal_connect (delete_event => sub { $_[0] -> destroy; });

# VBox for window
   my $vbox = Gtk2::VBox -> new;
   $window -> add ($vbox);

# HBox for devices
   my $hboxd = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxd, FALSE, FALSE, 0);

# device list
   my $labeld = Gtk2::Label -> new ("Device");
   $hboxd -> pack_start ($labeld, FALSE, FALSE, 0);

   my $optd = Gtk2::OptionMenu -> new;
   my $menud = Gtk2::Menu -> new;

# Need to define this here to reference it for later.
   my $vboxd = Gtk2::VBox -> new;

# parse out the device and model names
   my @device;
   if (! $test) {
    $output = `scanimage --formatted-device-list="%i %d.%v %m;" 2>/dev/null`;

    my $device = substr($output, 0, index($output, ";")+1);
    $output = substr($output, index($output, ";")+1, length($output));
    while ($device =~ /([0-9]*) (.*)\.(.*);/) {
     $device[$1] = $2;

# Convert all underscores to spaces
     (my $model = $3) =~ s/_/ /g;
     $device = substr($output, 0, index($output, ";")+1);
     $output = substr($output, index($output, ";")+1, length($output));

# read the device names into the optionmenu
     my $item = Gtk2::MenuItem -> new ($model);
     $item -> signal_connect (activate => sub {
      update_options($vboxd, $device[$optd -> get_history]);
      $vboxd -> show_all;
     });
     $menud -> append ($item);
    }
   }
   else {
    my $item = Gtk2::MenuItem -> new ($test);
    $item -> signal_connect (activate => sub {
     update_options($vboxd, undef);
     $vboxd -> show_all;
    });
    $menud -> append ($item);
    push @device, $test
   }
   $optd -> set_menu ($menud);
   $hboxd -> pack_end ($optd, FALSE, FALSE, 0);

# If there is a default device, then set it
   if ($output =~ /default device is `(.*)'/) {
    my $i = 0;
    ++$i while ($1 ne $device[$i]);
    $optd -> set_history($i);
   }
   
# Frame for # pages
   my $framen = Gtk2::Frame -> new('# Pages');
   $vbox -> pack_start ($framen, FALSE, FALSE, 0);
   my $vboxn = Gtk2::VBox -> new;
   $vboxn -> set_border_width(6);
   $framen -> add ($vboxn);

#the first radio button has to set the group,
#which is undef for the first button
# All button
   my $buttona = Gtk2::RadioButton -> new(undef, "All");
   $vboxn -> pack_start($buttona, TRUE, TRUE, 0);
   $buttona -> set_active(TRUE);
   my @groupn = $buttona -> get_group;

# Entry button
   my $hboxn = Gtk2::HBox -> new;
   $vboxn -> pack_start($hboxn, TRUE, TRUE, 0);
   my $buttone = Gtk2::RadioButton -> new(@groupn, "#:");
   $hboxn -> pack_start($buttone, FALSE, FALSE, 0);

# Number of pages
   my $spin_button = Gtk2::SpinButton -> new_with_range(1, 99, 1);
   $spin_button -> signal_connect ('value-changed' => sub {
    $buttone -> set_active(TRUE); # Set the radiobutton active
   });
   $hboxn -> pack_end ($spin_button, FALSE, FALSE, 0);

# Frame for source document
   my $frames = Gtk2::Frame -> new('Source document');
   $vbox -> pack_start ($frames, FALSE, FALSE, 0);
   my $vboxs = Gtk2::VBox -> new;
   $vboxs -> set_border_width(6);
   $frames -> add ($vboxs);

# Single sided button
   my $buttons = Gtk2::RadioButton -> new(undef, "Single sided");
   $vboxs -> pack_start($buttons, TRUE, TRUE, 0);
   $buttons -> set_active(TRUE);
   my @groups = $buttons -> get_group;

# Double sided button
   my $buttond = Gtk2::RadioButton -> new(@groups, "Double sided");
   $vboxs -> pack_start($buttond, FALSE, FALSE, 0);

# Facing/reverse page button
   my $hboxs = Gtk2::HBox -> new;
   $vboxs -> pack_start($hboxs, TRUE, TRUE, 0);
   my $labels = Gtk2::Label -> new ("Side to scan");
   $hboxs -> pack_start($labels, TRUE, TRUE, 0);

   my $opts = Gtk2::OptionMenu -> new;
   my $menus = Gtk2::Menu -> new;
   my @side = qw/Facing Reverse/;
   foreach (@side) {
    my $item = Gtk2::MenuItem -> new ($_);
    $item -> signal_connect ('activate' => sub {
     $buttond -> set_active(TRUE); # Set the radiobutton active
    });
    $menus -> append ($item);
   }
   $opts -> set_menu ($menus);
   $hboxs -> pack_end ($opts, FALSE, FALSE, 0);

# Frame for device-dependent options
   my $framed = Gtk2::Frame -> new('Device-dependent options');
   $vbox -> pack_start ($framed, FALSE, FALSE, 0);
   $vboxd -> set_border_width(6);
   $framed -> add ($vboxd);

# Dig the device-dependent options from --help --device-name
   if ($test) {
    update_options($vboxd, undef);
   }
   else {
    update_options($vboxd, $device[$optd -> get_history]);
   }

# HBox for buttons
   my $hboxb = Gtk2::HBox -> new;
   $vbox -> pack_end ($hboxb, FALSE, FALSE, 0);

# Scan button
   my $sbutton = Gtk2::Button -> new('Scan');
   $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
   $sbutton -> signal_connect (clicked => sub {

# Get selected device
    my $device = "--device-name=".$device[$optd -> get_history];

# Get device-specific options
    my %options;
    my @child = $vboxd -> get_children;
    foreach my $hbox (@child) {
     my $key;
     if ($hbox -> isa('Gtk2::HBox')) {
      my @child = $hbox -> get_children;
      foreach my $widget (@child) {
       if ($widget -> isa('Gtk2::Label')) {
        $key = $widget -> get_label;
       }
       elsif ($widget -> isa('Gtk2::OptionMenu')) {
        my @child = $widget -> get_children;
        foreach my $widget (@child) {

# ignore artificial paper size option
         if ($widget -> isa('Gtk2::Label') && $key ne 'Paper size') {
          $options{$key} = $widget -> get_label;
         }
        }
       }
       elsif ($widget -> isa('Gtk2::SpinButton')) {
        $options{$key} = $widget -> get_value;
       }
      }
     }
    }

# Get selected number of pages
    my $npages;
    if ($buttone -> get_active) {
     $npages = "--batch-count=".$spin_button -> get_value;
    }
    else {
     $npages = "";
    }

# Start from next available page
    my $start;
    if ($#{$slist -> {data}} > -1) {
     $start = $slist -> {data}[$#{$slist -> {data}}][0] + 1;
    }
    else {
     $start = 1;
    }

# Set step according to single/double sided, facing/reverse page
    my $step;
    if ($buttond -> get_active) {
     if (($opts -> get_history) == 0) { # facing page
      $step = 2;
     }
     else { # reverse page
      if ($start == 1) {
       my $dialog = Gtk2::MessageDialog -> new ($window,
        'destroy-with-parent',
        'error', # message type
        'cancel', # which set of buttons?
        "Must scan facing pages first");
       $dialog -> run;
       $dialog -> destroy;
       return 1;
      }

      $step = -2;

# Check that there is room in the list for the reverse pages
      my $i = 1;
      my $j = $#{$slist -> {data}};
      while ($slist->{data}[$j][0] != $start+$i*$step
             && $start+$i*$step > 0
             && $j > -1) {
       if ($slist->{data}[$j][0] > $start+$i*$step) {
        --$j;
       }
       else {
        ++$i;
       }
      }
      if ($buttone -> get_active) {
       if (($spin_button -> get_value) > $i) {
        my $dialog = Gtk2::MessageDialog -> new ($window,
         'destroy-with-parent',
         'error', # message type
         'cancel', # which set of buttons?
         "Cannot scan more reverse pages\nthan facing pages");
        $dialog -> run;
        $dialog -> destroy;
        return 1;
       }
      }

# If user hasn't specified number of pages, then set number that is undefined
      else {
       $npages = "--batch-count=".$i;
      }
     }
     $step = "--batch-increment=".$step;
    }
    else {
     $step = "";
    }
    $start = "--batch-start=".$start;
    do_scan($device, $npages, $start, $step, %options);
   } );

# Cancel button
   my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
   $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
   $cbutton -> signal_connect( clicked => sub { $window -> destroy; } );

   $window -> show_all;
   $hboxc -> hide_all if ($#paper > -1);
  }
 }
}


# Carry out the scan with the options passed.

sub do_scan {
 my ($device, $npages, $start, $step, %options) = @_;

# Basic options
 my @options = ( '--format=tiff',  
                 '--batch' );

# Add device-specific options
 my ($key, $value);
 while (($key, $value) = each(%options)) {
  if ($key eq 'x' || $key eq 'y') {
   push @options, "-$key=$value";
  }
  else {
   push @options, "--$key=$value";
  }
 }

# Make sure we are in temp directory
 chdir $dir;

# Create command
 my $cmd = "scanimage $device $npages $start $step @options;echo 'End Scan' > /dev/stderr";

 if (! $test) {

# Interface to scanimage
  my ($write, $read);
  my $error = IO::Handle -> new; # this needed because of a bug in open3.
  my $pid = open3($write, $read, $error, $cmd);
  
  my $dialog = Gtk2::Dialog -> new ("Scanning...", $window,
                                    'destroy-with-parent',
                                    'gtk-cancel' => 'cancel');
  my $label = Gtk2::Label -> new ("Scanning...");
  $dialog -> vbox -> add ($label);

# Ensure that the dialog box is destroyed when the user responds.
  $dialog -> signal_connect (response => sub {
   $_[0] -> destroy;
   local $SIG{HUP} = 'IGNORE';
   kill HUP => $pid;
  });
  $dialog -> show_all;
 
  my $line;
  Glib::IO -> add_watch(fileno($error), 'in', sub {
   my $buffer;
   sysread $error, $buffer, 1024;
   $line = $line . $buffer; # needed to cover case where line is broken in middle
   while ($line =~ /\n/) {
    if ($line =~ /^Scanning (-?[0-9]*) pages/) {
     $label -> set_text("Scanning $1 pages...");
    }
    elsif ($line =~ /^Scanning page ([0-9]*)/) {
     $label -> set_text("Scanning page $1...");
    }
    elsif ($line =~ /^Scanned page ([0-9]*)\. \(scanner status = 5\)/) {
     import_scan ("out$1.tif");
    }
    elsif ($line =~ /^End Scan/) {
     $dialog -> destroy;
     return 0; # Sascha Hunold [hunoldinho at users dot sourceforge dot net]
    }
    else {
#     $dialog -> destroy;
     my $text = "Unknown message: " . substr($line, 0, index($line, "\n"));
warn "$text\n";
     my $dialog = Gtk2::MessageDialog -> new ($window,
                                              'destroy-with-parent',
                                              'error',
                                              'close',
                                              $text);
    }
    $line = substr($line, index($line, "\n")+1, length($line));
   }
   return 1;
  });
 }
 else {
  warn "$cmd\n";
 }
}


# Take new scan and display it

sub import_scan {
 my ($ofilename) = @_;
 my (undef, $filename) = tempfile(DIR => $dir);
 system("mv $ofilename $filename");

 my $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file ($filename);

# Get dimension for image
 my $widthi = $src_pixbuf -> get_width;
 my $heighti = $src_pixbuf -> get_height;

# Calculate scale factor for thumbnail, being conservative
 my $scale = ($widtht-1)/$widthi < ($heightt-1)/$heighti ? ($widtht-1)/$widthi : ($heightt-1)/$heighti;

 my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                        $src_pixbuf -> get_has_alpha, 
                                        $src_pixbuf -> get_bits_per_sample,
                                        $widthi*$scale, $heighti*$scale);
 zoom_pixbuf($src_pixbuf, $pixbuf, $scale);

# Add to the page list
 my $i;
 if ($ofilename =~ /out([0-9]*)\.tif/) {
  $i = $1;
 }
 else {
  $i = $#{$slist -> {data}}+2;
 }
 push @{$slist -> {data}}, [$i, $pixbuf, $filename];

# Select new page, deselecting others. This fires the select callback,
# displaying the page
 $slist -> get_selection -> unselect_all;
 my @page;

# Due to the sort, must search for new page
 $page[0] = 0;
 ++$page[0] while ($slist -> {data}[$page[0]][0] != $i);

 $slist -> select(@page);
}


# Delete the selected scans

sub do_delete {
 my @page = $slist -> get_selected_indices;
 while ($#page > -1) {
  splice @{ $slist->{data} }, $page[0], 1;
  @page = $slist -> get_selected_indices;
 }
}


# Select all scans

sub do_select_all {
 $slist -> get_selection -> select_all;
}


# Display about dialog

sub do_about {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'info', 'ok', "$program v$version\n\n"
                     . "To aid the scan-to-PDF process.\n\n"
                     . "Copyright Jeff Ratcliffe\n"
                     . "Licensed under the GPLv2");
 $dialog -> run;
 $dialog -> destroy;
}


# Check that tiffcp & tiff2pdf exist

sub check_utils {
 system("which tiffcp >/dev/null 2>/dev/null");
 return $? if $? != 0;
 system("which tiff2pdf >/dev/null 2>/dev/null");
 return $? if $? != 0;
 return 0;
}


# Update device-dependent scan options

sub update_options {
 my ($vboxd, $device) = @_;

# Empty $vboxd first
 my @child = $vboxd -> get_children;
 foreach (@child) {
  $_ -> destroy;
 }

 my $output;
 if (defined($device)) {

# Get output from scanimage
  $output = `scanimage --help --device-name=$device`;
 }
 else {

# Slurp it from file
  $output = do { local( @ARGV, $/ ) = $test ; <> } ;
 }

# Skip to the device-specific options
 $output = substr($output, index($output, "Options specific to device"), length($output));
 $output = substr($output, index($output, "\n")+1, length($output));

# Dig out the paper sizes
 my ($x, $y);
 $x = $1 if ($output =~ /-x 0\.\.([0-9]*\.?[0-9]*)/);
 $y = $1 if ($output =~ /-y 0\.\.([0-9]*\.?[0-9]*)/);

 if (defined($x) && defined($y)) {

# HBox for paper size
  my $hboxp = Gtk2::HBox -> new;
  $vboxd -> pack_start ($hboxp, FALSE, FALSE, 0);

# Paper list
  my $labelp = Gtk2::Label -> new ("Paper size");
  $hboxp -> pack_start ($labelp, FALSE, FALSE, 0);

  my $optp = Gtk2::OptionMenu -> new;
  my $menup = Gtk2::Menu -> new;

# Define custom paper here to reference it in callback
  $hboxc = Gtk2::HBox -> new;
  my $spin_buttonx = Gtk2::SpinButton -> new_with_range(0, $x, 1);
  my $spin_buttony = Gtk2::SpinButton -> new_with_range(0, $y, 1);

# Add paper size to optionmenu if scanner large enough
# can't use for because of the splices
  my $i = 0;
  while ($i <= $#paper) {
   if ($x >= $x[$i] && $y >= $y[$i]) {
    my $item = Gtk2::MenuItem -> new ($paper[$i]);
    $item -> signal_connect (activate => sub {
     my $i = $optp -> get_history;
     $spin_buttonx -> set_value($x[$i]);
     $spin_buttony -> set_value($y[$i]);
     $hboxc -> hide_all;
    });
    $menup -> append ($item);
    ++$i;
   }

# If the paper size isn't possible, remove it from the arrays
   else {
    splice @paper, $i, 1;
    splice @x, $i, 1;
    splice @y, $i, 1;
   }
  }

# Add custom option
  my $item = Gtk2::MenuItem -> new ('Custom');
  $item -> signal_connect (activate => sub { $hboxc -> show_all; });
  $menup -> append ($item);
  $optp -> set_menu ($menup);
  $hboxp -> pack_end ($optp, FALSE, FALSE, 0);

# Set default options
  if ($#paper > -1) {
   $i = $optp -> get_history;
   $spin_buttonx -> set_value($x[$i]);
   $spin_buttony -> set_value($y[$i]);
  }
  else {
   $spin_buttonx -> set_value($x);
   $spin_buttony -> set_value($y);
  }

  $vboxd -> pack_start ($hboxc, FALSE, FALSE, 0);

# custom paper x entry
  my $labelx = Gtk2::Label -> new ("x");
  $hboxc -> pack_start ($labelx, FALSE, FALSE, 0);
  $hboxc -> pack_start ($spin_buttonx, FALSE, FALSE, 0);

# custom paper y entry
  my $labely = Gtk2::Label -> new ("y");
  $hboxc -> pack_start ($labely, FALSE, FALSE, 0);
  $hboxc -> pack_start ($spin_buttony, FALSE, FALSE, 0);
 }

# Add remaining options
 while ($output =~ /--([a-z_-]*)(.*) \[(.*)\]/) {
  my $option = $1;
  my $values = $2;
  my $default = $3;
  if ($option =~ /(^mode$|^resolution$|^batch-scan$|^wait-for-button$)/
      && $default !~ /inactive/) {

# HBox for option
   my $hbox = Gtk2::HBox -> new;
   $vboxd -> pack_start ($hbox, TRUE, TRUE, 0);

# Label
   my $label = Gtk2::Label -> new ($option);
   $hbox -> pack_start ($label, FALSE, FALSE, 0);

# OptionMenu
   if ($values =~ /\|/) {
    my $opt = Gtk2::OptionMenu -> new;
    my $menu = Gtk2::Menu -> new;

# Counters for defaults
    my $i = -1;
    my $o;

# Parse items from output
    while ($values =~ /\|/) {
     my $value = substr($values, 0, index($values, "|"));
     $values = substr($values, index($values, "|")+1, length($values));
     $value = substr($value, 1, length($value)) while ($value =~ /^ /);
     $value = substr($value, 3, length($value)) while ($value =~ /^\[=\(/);

# Create item
     my $item = Gtk2::MenuItem -> new ($value);
     $menu -> append ($item);
     $i++;
     $o = $i if ($value eq $default);
    }

# Do it all again for the last one
    $values = substr($values, 0, length($values)-2) while ($values =~ /\)\]/);
    my $item = Gtk2::MenuItem -> new ($values);
    $menu -> append ($item);
    $i++;
    $o = $i if ($values eq $default);

# Create OptionMenu
    $opt -> set_menu ($menu);
    $opt -> set_history ($o);
    $hbox -> pack_end ($opt, FALSE, FALSE, 0);
   }

# SpinButton
   elsif ($values =~ /([0-9]*\.?[0-9]*)\.\.([0-9]*\.?[0-9]*)/) {
    my $spin_button = Gtk2::SpinButton -> new_with_range($1, $2, 1);
    $spin_button -> set_value($default);
    $hbox -> pack_end ($spin_button, FALSE, FALSE, 0);
   }
  }
  $output = substr($output, index($output, "]")+1, length($output));
 }
}


__END__

=head1 NAME

gscan2pdf - A GUI to ease the process of producing PDFs from scanned documents

=head1 SYNOPSIS

1. Scan one or several pages in with File/Scan
2. Create PDF of selected pages with File/Save PDF

=head1 DESCRIPTION

At maturity, the GUI will have similar features to that of the Windows Imaging
program, but with the express objective of writing a PDF, including metadata.

Scanning is handled with SANE via scanimage.
PDF conversion is done by libtiff.

Perl is used for portability and ease of programming, with gtk2-perl for the
GUI. This should therefore work more or less out of the box on any system with
Perl, gtk2-perl, scanimage and libtiff.

=head1 SEE ALSO

Requires perl, libgtk2-perl (>=1.100-1), libglib-perl (>= 1.100-1), scanimage
and libtiff.

=head1 AUTHOR

Jeffrey Ratcliffe

=cut
