#!/usr/bin/perl

# Copyright (c) 2006 by Jeff Ratcliffe (ra28145 at users dot sourceforge dot net)
# This script is released under the GPL license.  Please
# see the included LICENSE file for details.

# To do
# 0. Add status line at bottom with messages like "filename saved"
#    Add Gnome menu
#    Rewrite menus with SimpleMenu to get same icons as buttons
#    Use  $tree_view->window->set_cursor( Gtk2::Gdk::Cursor->new('watch') );
#      and    $tree_view->window->set_cursor (undef); when working.
#    Add dialog whilst device-dependent options are being parsed
#    Add hidden flag whether a page has been saved
#    On quit or delete if page not saved put up dialog
#    Put windows up in centre of parent
#    Scanning window doesn't have a proper icon.
#    Get scanimage calls down to minimum
#    Fix blocking at:
#      First opening scan window
#      Changing device
#      Importing
#    Note in podviewer message about help from command line + information about
#    package required. Or better still, work out how best to include package.
#    Option to throw up PDF viewer with newly created PDF file
# 1. Implement right-click, following ItemFactory example tutorial/rightclick.pl
# 2. Translations
# 3. Progress meter for scans and imports.
# 4. Rotate
# 5. Crop and autocrop
# 6. Look at OCR

# Release procedure:
# 1. Make tar dist
# 2. Upload to sourceforge and release files
# 3. Freshmeat
# 4. Launchpad
# 5. http://www.gtkfiles.org/app.php/gscan2pdf
# 6. Ubuntu forum

use warnings;
use strict;
use IPC::Open3;
use IO::Handle;
use Gtk2 -init;
use Gtk2::SimpleList;
use Cwd;                             # To obtain current working directory
use File::Basename;                  # Split filename into dir, file, ext
use File::Temp qw(tempfile tempdir); # To create temporary files
use Glib qw(TRUE FALSE);             # To get TRUE and FALSE
use POSIX qw(locale_h);              # To sort out LC_NUMERIC

my $program = "gscan2pdf";
my $version = "0.7.5";

# Standard paper sizes
my @paper = qw/A4 Letter/;
my @x = ( 210, 215.9 );
my @y = ( 297, 279.4 );

# Window parameters
my $border_width = 6;

# Set up test mode and make sure file has absolute path
my $test = FALSE;
while (defined($ARGV[0])) {
 if ($ARGV[0] eq "--test") {
  $test = $ARGV[1];
  $test = getcwd."/$test" if ($test !~ /^\//);
  shift @ARGV;
  shift @ARGV;
 }
 elsif ($ARGV[0] eq "--help") {
  system("perldoc $0");
  exit;
 }
}

if (check_utils()) {
 print "$program requires the libtiff library.\nPlease install it.\n";
 exit 1;
}

# Set LC_NUMERIC to C to prevent decimal commas (or anything else) confusing
# scanimage
setlocale(LC_NUMERIC, "C");

# Read config file
my $config = "$ENV{'HOME'}/.$program";
my %SETTING;
if (-r $config) {
 open CONFIG, $config or die "Can't open config file $config";

 while (<CONFIG>) {
  chomp;			# no newline
  s/#.*//;			# no comments
  s/^\s+//;			# no leading white
  s/\s+$//;			# no trailing white
  next unless length;		# anything left?
  my ($key, $value) = split(/\s*=\s*/, $_, 2);
  $SETTING{$key} = $value;
 }
 close CONFIG;
}

# Define application-wide variables here so that they can be referenced
# in the menu callbacks
my ($windowp, $windowt, $windows, $windowh, $slist);

# Define the menu items for ItemFactory
my @menu_items = ( { path        => '/_File',
		     item_type   => '<Branch>' },
		   { path        => '/File/_New',
		     accelerator => '<control>n',
		     callback    => \&new },
		   { path        => '/File/_Import',
		     accelerator => '<control>i',
		     callback    => \&import },
		   { path        => '/File/Sca_n',
		     callback    => sub { if (defined($windows)) {
                                           $windows -> present;
                                          }
                                          else {
                                           scan_dialog();
                                          } } },
		   { path        => '/File/_Save PDF',
		     accelerator => '<control>s',
		     callback    => sub { if (defined($windowp)) {
                                           $windowp -> present;
                                          }
                                          else {
                                           save_PDF();
                                          } } },
		   { path        => '/File/Save _TIFF',
		     accelerator => '<control>t',
		     callback    => sub { if (defined($windowt)) {
                                           $windowt -> present;
                                          }
                                          else {
                                           save_TIFF();
                                          } } },
		   { path        => '/File/sep1',
		     item_type   => '<Separator>' },
		   { path        => '/File/_Quit',
		     accelerator => '<control>q',
		     callback    => sub { quit(); Gtk2 -> main_quit; } },

		   { path        => '/_Edit',
		     item_type   => '<Branch>' },
		   { path        => '/Edit/_Delete',
		     accelerator => 'Delete',
		     callback    => \&delete_pages },
		   { path        => '/Edit/_Renumber',
		     accelerator => '<control>r',
		     callback    => sub { renumber($slist, 0, 1, 1); } },
		   { path        => '/Edit/Select _All',
		     accelerator => '<control>a',
		     callback    => \&select_all },

		   { path        => '/_View',
		     item_type   => '<Branch>' },
		   { path        => '/View/Zoom _100%',
		     callback    => sub { zoom_button('100%'); } },
		   { path        => '/View/Zoom to _fit',
		     callback    => sub { zoom_button('fit'); } },
		   { path        => '/View/Zoom _in',
		     accelerator => 'plus',
		     callback    => sub { zoom_button('in'); } },
		   { path        => '/View/Zoom _out',
		     accelerator => 'minus',
		     callback    => sub { zoom_button('out'); } },

		   { path        => '/_Help',
		     item_type   => '<LastBranch>' },
		   { path        => '/Help/_Help',
		     accelerator => '<control>h',
		     callback    => sub { if (defined($windowh)) {
                                           $windowh -> present;
                                          }
                                          else {
                                           view_pod();
                                          } } },
		   { path        => '/Help/_About',
		     callback    => \&about } );

# Create the window
my $window = Gtk2::Window -> new;
$window -> set_title ( "$program v$version" );
$window -> signal_connect ( destroy => sub { quit(); Gtk2 -> main_quit; } );

# Note when the window is maximised or not.
$window -> signal_connect(window_state_event => sub {
 my ($w, $event) = @_;
 if ($event -> new_window_state & [ 'maximized' ]) {
  $SETTING{"window_maximize"} = 1;
 }
 else {
  $SETTING{"window_maximize"} = 0;
 }
});

# If defined in the config file, set the window state, size and position
if (defined($SETTING{"window_width"}) and defined($SETTING{"window_height"})) {
 $window -> set_default_size ($SETTING{"window_width"}, $SETTING{"window_height"});
}
else {
 $window -> set_default_size (800, 600);
}
if (defined($SETTING{"window_x"}) and defined($SETTING{"window_y"})) {
 $window -> move ($SETTING{"window_x"}, $SETTING{"window_y"});
}
$window -> maximize
 if (! (defined($SETTING{"window_maximize"}) and ! $SETTING{"window_maximize"}));

# Pass the window a stock icon list
my @icon;
my $i = -1;
foreach my $size (qw/menu small-toolbar large-toolbar button dnd dialog/) {
 ++$i;
 $icon[$i] = $window -> render_icon ('gtk-print-preview', $size) # or gtk-index
}
$window -> set_icon_list ( @icon );

my $main_vbox = new Gtk2::VBox ( FALSE, 1 );
$window -> add ( $main_vbox );

# Create the menu bar
my $menubar = create_menu_bar( $window );
$main_vbox -> pack_start( $menubar, FALSE, TRUE, 0 );

my $tooltips = Gtk2::Tooltips->new;

# Button hbox
my $hboxb = Gtk2::HBox -> new;
$main_vbox -> pack_start ($hboxb, FALSE, FALSE, 0);

foreach (
 [ 'gtk-new',            'Clears all pages', \&new ],
 [ 'gtk-open',           'Import TIFF file', \&import ],
 [ 'gtk-print',          'Scan document', sub { if (defined($windows)) {
                                                 $windows -> present;
                                                }
                                                else {
                                                 scan_dialog();
                                                } } ],
 [ 'gtk-save-as',        'Save as PDF', sub { if (defined($windowp)) {
                                               $windowp -> present;
                                              }
                                              else {
                                               save_PDF();
                                              } } ],
 [ 'gtk-save',           'Save as TIFF', sub { if (defined($windowt)) {
                                                $windowt -> present;
                                               }
                                               else {
                                                save_TIFF();
                                               } } ],
 [ 'gtk-delete',         'Delete selected pages', \&delete_pages ],
 [ 'gtk-sort-ascending', 'Renumber pages from 1 to n', sub {
                                                 renumber($slist, 0, 1, 1); } ],
 [ 'gtk-select-all',     'Select all pages', \&select_all ],
 [ 'gtk-zoom-100',       'Zoom to 100%', sub { zoom_button('100%'); } ],
 [ 'gtk-zoom-fit',       'Zoom to fit', sub { zoom_button('fit'); } ],
 [ 'gtk-zoom-in',        'Zoom in', sub { zoom_button('in'); } ],
 [ 'gtk-zoom-out',       'Zoom out', sub { zoom_button('out'); } ],
 [ 'gtk-help',           'Help', sub { if (defined($windowh)) {
                                           $windowh -> present;
                                          }
                                          else {
                                           view_pod();
                                          } } ],
 [ 'gtk-quit',           'Quit', sub { quit(); Gtk2 -> main_quit; } ]
) {
 if (defined(Gtk2::Stock->lookup ($_->[0]))) {
  my $button = Gtk2::Button->new;
  my $image = Gtk2::Image->new_from_stock ($_->[0], 'large-toolbar');
  $button->add ($image);
  $button -> signal_connect(clicked => $_->[2]);
  $hboxb -> pack_start ($button, FALSE, FALSE, 0);
  $tooltips->set_tip ($button, $_->[1]);
 }
}
$tooltips->enable;

# HPaned for thumbnails and detail view
my $hpaned = Gtk2::HPaned -> new;
$main_vbox -> pack_start($hpaned, TRUE, TRUE, 0);

# Thumbnail dimensions
my $widtht = 100;
my $heightt = 100;
if (defined($SETTING{"thumb panel"})) {
 $hpaned -> set_position ($SETTING{"thumb panel"});
}
else {
 $hpaned -> set_position ($widtht);
}

# Scrolled window for thumbnails
my $scwin_thumbs = Gtk2::ScrolledWindow -> new;
$hpaned -> pack1 ($scwin_thumbs, TRUE, TRUE);
$scwin_thumbs -> set_policy ('automatic', 'automatic');

# define filename and i to be hidden
Gtk2::SimpleList -> add_column_type( 'filename',
                                     type => 'Glib::String',
                                     attr => 'hidden' );

# Set up a SimpleList
$slist = Gtk2::SimpleList -> new('#' => 'int',
                                   'Thumbnails' => 'pixbuf',
                                   'Filename' => 'filename');

# Callback for dropped signal.
$slist -> signal_connect('drag_drop' => sub {
# Block row-changed signal so that the list can be renumbered before the sort
# takes over.
 $slist -> get_model -> signal_handler_block($slist -> {signalid});
 return 0;
});

# Now that drag_drop has returned,
# check that the numbering is ascending and renumber if needed.
$slist->signal_connect (drag_end => sub {
 renumber($slist, 0);
 $slist -> get_model -> signal_handler_unblock($slist -> {signalid});
 return 0;
});

$slist -> get_selection -> set_mode ('multiple');
$slist -> set_headers_visible(FALSE);
$slist -> set_reorderable( TRUE );

# Set the page number to be editable
$slist -> set_column_editable (0, TRUE);

# Set-up the callback when the page number has been edited.
$slist -> {signalid} = $slist -> get_model ->
 signal_connect('row-changed' => sub {
  $slist -> get_model -> signal_handler_block($slist -> {signalid});

# Sort pages
  manual_sort_by_column ($slist, 0);

# And make sure there are no duplicates
  renumber ($slist, 0);
  $slist -> get_model -> signal_handler_unblock($slist -> {signalid});
 });

$scwin_thumbs -> add_with_viewport($slist);

# Scrolled window for detail view
my $scwin_detail = Gtk2::ScrolledWindow -> new;
$hpaned -> pack2 ($scwin_detail, TRUE, TRUE);
$scwin_detail -> set_policy ('automatic', 'automatic');

# Globally define the $image variables for $scwin_detail
my $image;
my $scale;
my $src_pixbuf;
my $widthi;
my $heighti;

# Globally define the custom paper box.
my $hboxc;

# Set up call back for list selection to update detail view
$slist -> get_selection -> signal_connect(changed => sub {
 my @page = $slist -> get_selected_indices;

# Remove any image in the detail window
 if (defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
 }

# Display the new image
 if ($#page > -1) {

# Get dimensions for detail window
  my $widthd = $scwin_detail -> allocation -> width;
  my $heightd = $scwin_detail -> allocation -> height;

  $image = Gtk2::Image -> new;

# scalar needed for reasons I don't understand, but which have to do with
# converting the array to a scalar. Alternatively, it might be a bug.
  $src_pixbuf = Gtk2::Gdk::Pixbuf ->
                            new_from_file (scalar($slist->{data}[$page[0]][2]));

# Get dimension for image
  $widthi = $src_pixbuf -> get_width;
  $heighti = $src_pixbuf -> get_height;

# Calculate scale factor to fit window, being conservative
  $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti
                                 ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;

  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
});

# If defined in the config file, set the current directory
$SETTING{"cwd"} = getcwd if (! defined($SETTING{"cwd"}));

# Create a temporary directory for scans
my $dir = tempdir;

$window -> show_all;
Gtk2 -> main;



### Subroutines

# Create the menu bar, initialize its menus, and return the menu bar.

sub create_menu_bar {
 my ($window) = @_;

 my $accel_group = new Gtk2::AccelGroup;

 # This function initializes the item factory.
 # Param 1: The type of menu - can be 'Gtk2::MenuBar', 'Gtk2::Menu',
 #          or 'Gtk2::OptionMenu'.
 # Param 2: The path of the menu.
 # Param 3: The accelerator group.  The item factory sets up
 #          the accelerator table while generating menus.
 my $item_factory = new Gtk2::ItemFactory( 'Gtk2::MenuBar', '<main>',
                                                                 $accel_group );

 # This function generates the menu items. Pass the item factory,
 # the number of items in the array, the array itself, and any
 # callback data for the the menu items.
 $item_factory -> create_items( @menu_items );

 # Attach the new accelerator group to the window.
 $window -> add_accel_group( $accel_group );

 # Finally, return the actual menu bar created by the item factory.
 #*menubar = gtk_item_factory_get_widget (item_factory, "<main>");
 return ( $item_factory -> get_widget( '<main>' ) );
}


# Zoom the detail window

sub zoom_button {
 my $button = $_[0];
 if (defined($scwin_detail) and defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
  if ($button eq '100%') {
   $scale = 1;
  }
  elsif ($button eq 'in') {
   $scale *= 1.2;
  }
  elsif ($button eq 'out') {
   $scale /= 1.2;
  }
  else {
   my $widthd = $scwin_detail -> allocation -> width;
   my $heightd = $scwin_detail -> allocation -> height;
   $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti
                                  ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;
  }
  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
}


# Zoom the image

sub zoom_pixbuf {
 my ($src, $dest, $scale) = @_;
 $src -> composite ($dest, 0, 0, $dest -> get_width,
                                 $dest -> get_height, 
                    0, 0, $scale, $scale, 'bilinear', 255);
}


# Deletes all scans after warning.

sub new {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'warning', 'ok-cancel',
                     "This will clear the list of scanned images.\n"
                     . "Do you want to continue?");
 if ($dialog -> run eq 'ok') {

# Remove any image in the detail window
  if ($image) {
   my $viewport = $image -> get_parent;
   $image -> destroy;
   $viewport -> destroy;
  }

# Depopulate the thumbnail list
  while ($#{$slist -> {data}} > -1) {
   pop @{$slist -> {data}};
  }
 }
 $dialog -> destroy;
}


# Throw up file selector and import selected file

sub import {

# cd back to cwd to get filename
 chdir $SETTING{"cwd"};

 my $file_chooser = Gtk2::FileChooserDialog -> new('Import scan from file',
                                      $window, 'open',
                                      'gtk-cancel' => 'cancel',
                                      'gtk-ok' => 'ok');
 $file_chooser -> set_select_multiple(TRUE);

# cd back to tempdir to import
 chdir $dir;

 if ('ok' eq $file_chooser->run) {
  my @filename = $file_chooser -> get_filenames;

  foreach my $filename (@filename) {

# Update cwd
   $SETTING{"cwd"} = dirname($filename);

# Check that the file really is a tiff
   my $output = `tiffinfo \"$filename\" 2>&1 1>/dev/null`;
   if ($output =~ /Not a TIFF file/) {
    my $dialog = Gtk2::MessageDialog -> new ($window,
                                            'destroy-with-parent',
                                            'error',
                                            'close',
                                            "Not a TIFF file");
    $dialog -> run;
    $dialog -> destroy;
   }
   else {
    my $dialog = Gtk2::Dialog -> new ("Importing...", $window,
                                      'destroy-with-parent',
                                      'gtk-cancel' => 'cancel');

# Set up ProgressBar
    my $pbar = new Gtk2::ProgressBar;
    $pbar -> set_pulse_step(.1);
    $dialog -> vbox -> add($pbar);

# Timer will run until callback returns false 
#    my $timer = Glib::Timeout->add (100, sub {$pbar->pulse; return 1;});
    $pbar->set_fraction(.5);
    $dialog -> show_all;

# Split the tiff into its pages and import them individually
    system("tiffsplit \"$filename\"");
    $pbar->set_fraction(1);
    my @pages = <x???.tif>;
    foreach (@pages) {
     import_scan($_);
    }
    
#    Glib::Source -> remove($timer);
    $dialog -> destroy;
   }

  }
 }

 $file_chooser -> destroy;
}


# Throw up file selector and save selected pages as PDF under given name.

sub save_PDF {

# PDF pop-up window
 $windowp = Gtk2::Window -> new;
 $windowp -> set_border_width($border_width);
 $windowp -> set_title ('Save as PDF');
 $windowp -> signal_connect (delete_event => sub {
  $windowp -> hide;
  return TRUE; # ensures that the window is not destroyed
 });
 $windowp -> set_transient_for($window); # Assigns parent

# VBox for window
 my $vbox = Gtk2::VBox -> new;
 $windowp -> add ($vbox);

# Frame for metadata
 my $framem = Gtk2::Frame -> new('Metadata');
 $vbox -> pack_start ($framem, TRUE, TRUE, 0);
 my $vboxm = Gtk2::VBox -> new;
 $vboxm -> set_border_width($border_width);
 $framem -> add ($vboxm);

# Date/time
 my $hboxe = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxe, TRUE, TRUE, 0);
 my $labele = Gtk2::Label -> new ("Date");
 $hboxe -> pack_start ($labele, FALSE, FALSE, 0);
 if (! (defined($SETTING{'year'}) and defined($SETTING{'month'})
                               and defined($SETTING{'day'}))) {
  ($SETTING{'day'}, $SETTING{'month'}, $SETTING{'year'})
                                                       = (localtime())[3, 4, 5];
  $SETTING{'year'} += 1900;
  $SETTING{'month'} += 1;
 }
 my $button = Gtk2::Button ->
                      new("$SETTING{'year'}/$SETTING{'month'}/$SETTING{'day'}");
 $button -> signal_connect( clicked => sub {
  my $window = Gtk2::Window -> new;
  $window -> set_title ('Select Date' );
  $window->set_border_width($border_width);
  $window->signal_connect( 'destroy' => sub { $window -> destroy; } );
  $window->set_resizable(FALSE);
  $window -> set_transient_for($windowp); # Assigns parent

  my $vbox = Gtk2::VBox -> new;
  $window -> add($vbox);

  my $calendar = Gtk2::Calendar -> new;
  $calendar -> select_day($SETTING{'day'});
  $calendar -> select_month($SETTING{'month'}-1, $SETTING{'year'});
  $vbox -> pack_start ($calendar, TRUE, TRUE, 0);

  $calendar -> signal_connect(day_selected_double_click => sub {
   ($SETTING{'year'}, $SETTING{'month'}, $SETTING{'day'}) = $calendar ->
                                                                       get_date;
   $SETTING{'month'} += 1;
   $button -> set_label ("$SETTING{'year'}/$SETTING{'month'}/$SETTING{'day'}");
   $window -> destroy;
  });

  $window -> show_all;
 } );
 $tooltips -> set_tip ($button, 'Year/Month/Day');
 $hboxe -> pack_end( $button, TRUE, TRUE, 0 );

# Document author
 my $hboxa = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxa, TRUE, TRUE, 0);
 my $labela = Gtk2::Label -> new ("Document author");
 $hboxa -> pack_start ($labela, FALSE, FALSE, 0);
 my $entrya = Gtk2::Entry -> new;
 $hboxa -> pack_end( $entrya, TRUE, TRUE, 0 );
 $entrya -> set_text($SETTING{"author"}) if (defined($SETTING{"author"}));

# Title
 my $hboxt = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxt, TRUE, TRUE, 0);
 my $labelt = Gtk2::Label -> new ("Title");
 $hboxt -> pack_start ($labelt, FALSE, FALSE, 0);
 my $entryt = Gtk2::Entry -> new;
 $hboxt -> pack_end( $entryt, TRUE, TRUE, 0 );
 $entryt -> set_text($SETTING{"title"}) if (defined($SETTING{"title"}));

# Subject
 my $hboxs = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxs, TRUE, TRUE, 0);
 my $labels = Gtk2::Label -> new ("Subject");
 $hboxs -> pack_start ($labels, FALSE, FALSE, 0);
 my $entrys = Gtk2::Entry -> new;
 $hboxs -> pack_end( $entrys, TRUE, TRUE, 0 );
 $entrys -> set_text($SETTING{"subject"}) if (defined($SETTING{"subject"}));

# Keywords
 my $hboxk = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxk, TRUE, TRUE, 0);
 my $labelk = Gtk2::Label -> new ("Keywords");
 $hboxk -> pack_start ($labelk, FALSE, FALSE, 0);
 my $entryk = Gtk2::Entry -> new;
 $hboxk -> pack_end( $entryk, TRUE, TRUE, 0 );
 $entryk -> set_text($SETTING{"keywords"}) if (defined($SETTING{"keywords"}));

# Get help page to see what compression options are configured in tiff2pdf
 my $output = `tiff2pdf -h 2>&1 1>/dev/null`;
 my @compression = qw/None/;
 push @compression, 'Zip' if ($output =~ /-z/);
 push @compression, 'JPEG' if ($output =~ /-j/);

# Compression optionmenu
 my $hboxc = Gtk2::HBox -> new;
 $vbox -> pack_start($hboxc, TRUE, TRUE, 0);
 my $label = Gtk2::Label -> new ("Compression");
 $hboxc -> pack_start ($label, FALSE, FALSE, 0);
 my $optc = Gtk2::OptionMenu -> new;
 my $menuc = Gtk2::Menu -> new;

# Set up quality spinbutton here so that it can be shown or hidden by callback
 my $hboxq = Gtk2::HBox -> new;
 $vbox -> pack_start($hboxq, TRUE, TRUE, 0);
 $label = Gtk2::Label -> new ("JPEG Quality");
 $hboxq -> pack_start ($label, FALSE, FALSE, 0);
 my $spinbuttonq = Gtk2::SpinButton -> new_with_range(1, 100, 1);
 if (defined($SETTING{'quality'})) {
  $spinbuttonq->set_value($SETTING{'quality'});
 }
 else {
  $spinbuttonq->set_value(80);
 }
 $hboxq -> pack_end ($spinbuttonq, FALSE, FALSE, 0);

# Fill compression optionmenu
 my $i = 0;
 my $o;
 foreach my $compression (@compression) {
  my $item = Gtk2::MenuItem -> new ($compression);
  $menuc -> append ($item);
  $item -> signal_connect ('activate' => sub {
   if ($compression eq 'JPEG') {
    $hboxq -> show_all;
   }
   else {
    $hboxq -> hide_all;
   }
  });
  $o = $i
   if (defined($SETTING{'compression'})
       and $compression eq $SETTING{'compression'});
  ++$i;
 }
 $optc -> set_menu ($menuc);
 $optc -> set_history ($o) if defined($o);
 $hboxc -> pack_end ($optc, FALSE, FALSE, 0);

# Frame for page range
 my $framep = Gtk2::Frame -> new('Page range');
 $vbox -> pack_start ($framep, TRUE, TRUE, 0);
 my $vboxp = Gtk2::VBox -> new;
 $vboxp -> set_border_width($border_width);
 $framep -> add ($vboxp);

#the first radio button has to set the group,
#which is undef for the first button
# All button
 my $buttona = Gtk2::RadioButton -> new(undef, "All");
 $vboxp -> pack_start($buttona, TRUE, TRUE, 0);
 my @group = $buttona -> get_group;

# Current button
 my $buttonc = Gtk2::RadioButton -> new(@group, "Current");
 $vboxp -> pack_start($buttonc, TRUE, TRUE, 0);

# Selected button
 my $buttons = Gtk2::RadioButton -> new(@group, "Selected");
 $vboxp -> pack_start($buttons, TRUE, TRUE, 0);

# Set default
 if (defined($SETTING{"Page range"})) {
  if ($SETTING{"Page range"} eq "current") {
   $buttonc -> set_active(TRUE);
  }
  elsif ($SETTING{"Page range"} eq "selected") {
   $buttons -> set_active(TRUE);
  }
  else {
   $buttona -> set_active(TRUE);
  }
 }
 else {
  $buttona -> set_active(TRUE);
 }

# Pages button
# my $hboxp = Gtk2::HBox -> new;
# $vboxp -> pack_start($hboxp, TRUE, TRUE, 0);
# my $buttonp = Gtk2::RadioButton -> new(@group, "Pages:");
# $hboxp -> pack_start($buttonp, FALSE, FALSE, 0);

# Page List
# my $entryp = Gtk2::Entry -> new;
# $entryp -> signal_connect ('insert-text' => sub {
#  my ($widget, $string, $len, $position) = @_;
#  if ($string !~ /^[0-9]+$/) { # Only add numbers
#   $entryp -> signal_stop_emission_by_name ('insert-text');
#   $buttonp -> set_active(TRUE); # Set the radiobutton active
#  }
#  () # this callback must return either 2 or 0 items.
# });
# $hboxp -> pack_end ($entryp, FALSE, FALSE, 0);

# HBox for buttons
 my $hboxb = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Save button
 my $sbutton = Gtk2::Button -> new_from_stock('gtk-save');
 $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
 $sbutton -> signal_connect (clicked => sub {

# cd back to cwd to save
  chdir $SETTING{"cwd"};

# Set up file selector
  my $file_chooser = Gtk2::FileChooserDialog -> new('PDF filename',
                                                     $windowp, 'save',
                                                     'gtk-cancel' => 'cancel',
                                                     'gtk-save' => 'ok');

  if ('ok' eq $file_chooser->run) {
   my $filename = $file_chooser -> get_filename;
   if (-e $filename) {
    my $dialog = Gtk2::MessageDialog -> new ($file_chooser,
     'destroy-with-parent',
     'question', # message type
     'ok-cancel', # which set of buttons?
     "File $filename exists.\nReally overwrite?");
    my $response = $dialog -> run;
    $dialog -> destroy;
    return 1 if ($response ne 'ok');
   }

# Update cwd
   $SETTING{"cwd"} = dirname($filename);

# fill $pagelist with filenames depending on which radiobutton is active
   my $n;
   my $pagelist;
   if ($buttona -> get_active) {
    $SETTING{"Page range"} = "all";
    $n = $#{$slist -> {data}};
    $pagelist = $slist -> {data}[0][2];
    my $i = 1;
    while ($i <= $#{$slist -> {data}}) {
     $pagelist = $pagelist." ".$slist -> {data}[$i][2];
     ++$i;
    }
   }
   elsif ($buttonc -> get_active) {
    $SETTING{"Page range"} = "current";
    $n = 1;
    my @page = $slist -> get_selected_indices;
    $pagelist = $slist -> {data}[$page[0]][2];
   }
   elsif ($buttons -> get_active) {
    $SETTING{"Page range"} = "selected";
    my @page = $slist -> get_selected_indices;
    $n = $#page;
    $pagelist = $slist -> {data}[$page[0]][2];
    my $i = 1;
    while ($i <= $#page) {
     $pagelist = $pagelist." ".$slist -> {data}[$page[$i]][2];
     ++$i;
    }
   }

# Get metadata
   $SETTING{"author"} = $entrya -> get_text;
   $SETTING{"title"} = $entryt -> get_text;
   $SETTING{"subject"} = $entrys -> get_text;
   $SETTING{"keywords"} = $entryk -> get_text;

# Get compression
   $SETTING{'compression'} = $compression[$optc -> get_history];
   my $compression = "";
   if ($SETTING{'compression'} eq "JPEG") {
    $SETTING{'quality'} = get_value($spinbuttonq);
    $compression = "-j -d $SETTING{'quality'}";
   }
   elsif ($SETTING{'compression'} eq "Zip") {
    $compression = "-z";
   }

# Set options
   my $options = " $compression -o \"$filename\""
               . sprintf (" -e %4i%02i%02i", $SETTING{'year'}, $SETTING{'month'}, $SETTING{'day'})
               . " -c \"$program v$version\""
               . " -a \"$SETTING{'author'}\""
               . " -t \"$SETTING{'title'}\""
               . " -s \"$SETTING{'subject'}\""
               . " -k \"$SETTING{'keywords'}\"";

# call tiff2pdf and/or tiffcp according to the number of pages
   if ($n > 0) {
    system ("tiffcp $pagelist \"$filename.tif\"");
    system ("tiff2pdf $options \"$filename.tif\"");
    unlink ("$filename.tif"); # delete the temporary tiff
   }
   else {
    system ("tiff2pdf $options $pagelist");
   }
  
   $windowp -> hide;
  }

  $file_chooser -> destroy;

# cd back to tempdir
  chdir $dir;
 } );

# Cancel button
 my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
 $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
 $cbutton -> signal_connect( clicked => sub { $windowp -> hide; } );

 $windowp -> show_all;
 $hboxq -> hide_all
  if (! defined($SETTING{'compression'}) or $SETTING{'compression'} ne 'JPEG');
}


# Display page selector and on save a fileselector.

sub save_TIFF {

# PDF pop-up window
 $windowt = Gtk2::Window -> new;
 $windowt -> set_border_width($border_width);
 $windowt -> set_title ('Save as TIFF');
 $windowt -> signal_connect (delete_event => sub {
  $windowt -> hide;
  return TRUE; # ensures that the window is not destroyed
 });
 $windowt -> set_transient_for($window); # Assigns parent

# VBox for window
 my $vbox = Gtk2::VBox -> new;
 $windowt -> add ($vbox);

# Frame for page range
 my $framep = Gtk2::Frame -> new('Page range');
 $vbox -> pack_start ($framep, TRUE, TRUE, 0);
 my $vboxp = Gtk2::VBox -> new;
 $vboxp -> set_border_width($border_width);
 $framep -> add ($vboxp);

#the first radio button has to set the group,
#which is undef for the first button
# All button
 my $buttona = Gtk2::RadioButton -> new(undef, "All");
 $vboxp -> pack_start($buttona, TRUE, TRUE, 0);
 my @group = $buttona -> get_group;

# Current button
 my $buttonc = Gtk2::RadioButton -> new(@group, "Current");
 $vboxp -> pack_start($buttonc, TRUE, TRUE, 0);

# Selected button
 my $buttons = Gtk2::RadioButton -> new(@group, "Selected");
 $vboxp -> pack_start($buttons, TRUE, TRUE, 0);

# Set default
 if (defined($SETTING{"Page range"})) {
  if ($SETTING{"Page range"} eq "current") {
   $buttonc -> set_active(TRUE);
  }
  elsif ($SETTING{"Page range"} eq "selected") {
   $buttons -> set_active(TRUE);
  }
  else {
   $buttona -> set_active(TRUE);
  }
 }
 else {
  $buttona -> set_active(TRUE);
 }

# HBox for buttons
 my $hboxb = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Save button
 my $sbutton = Gtk2::Button -> new_from_stock('gtk-save');
 $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
 $sbutton -> signal_connect (clicked => sub {

# cd back to cwd to save
  chdir $SETTING{"cwd"};

# Set up file selector
  my $file_chooser = Gtk2::FileChooserDialog -> new('TIFF filename',
                                                     $windowt, 'save',
                                                     'gtk-cancel' => 'cancel',
                                                     'gtk-save' => 'ok');

  if ('ok' eq $file_chooser->run) {
   my $filename = $file_chooser -> get_filename;
   if (-e $filename) {
    my $dialog = Gtk2::MessageDialog -> new ($file_chooser,
     'destroy-with-parent',
     'question', # message type
     'ok-cancel', # which set of buttons?
     "File $filename exists.\nReally overwrite?");
    my $response = $dialog -> run;
    $dialog -> destroy;
    return 1 if ($response ne 'ok');
   }

# Update cwd
   $SETTING{"cwd"} = dirname($filename);

# cd back to tempdir
   chdir $dir;

# fill $pagelist with filenames depending on which radiobutton is active
   my $n;
   my $pagelist;
   if ($buttona -> get_active) {
    $SETTING{"Page range"} = "all";
    $n = $#{$slist -> {data}};
    $pagelist = $slist -> {data}[0][2];
    my $i = 1;
    while ($i <= $#{$slist -> {data}}) {
     $pagelist = $pagelist." ".$slist -> {data}[$i][2];
     ++$i;
    }
   }
   elsif ($buttonc -> get_active) {
    $SETTING{"Page range"} = "current";
    $n = 1;
    my @page = $slist -> get_selected_indices;
    $pagelist = $slist -> {data}[$page[0]][2];
   }
   elsif ($buttons -> get_active) {
    $SETTING{"Page range"} = "selected";
    my @page = $slist -> get_selected_indices;
    $n = $#page;
    $pagelist = $slist -> {data}[$page[0]][2];
    my $i = 1;
    while ($i <= $#page) {
     $pagelist = $pagelist." ".$slist -> {data}[$page[$i]][2];
     ++$i;
    }
   }

# Create the tiff
   system ("tiffcp $pagelist \"$filename\"");

   $windowt -> hide;
  }

  $file_chooser -> destroy;
 } );

# Cancel button
 my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
 $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
 $cbutton -> signal_connect( clicked => sub { $windowt -> hide; } );

 $windowt -> show_all;
}


# Scan

sub scan_dialog {

 my $output = `scanimage --version 2>/dev/null`;
 if ($? ne 0) {
  my $dialog = Gtk2::MessageDialog -> new ($window,
                                          'destroy-with-parent',
                                          'error',
                                          'close',
                                          "scanimage not found");
  $dialog -> run;
  $dialog -> destroy;
  return 0;
 }
 my @output = `scanimage --list-devices 2>/dev/null`;
 if ($? eq 0) {
  if ($#output > 1 and $output[0] =~ /^\s$/ 
                   and $output[1] =~ /^No scanners were identified/
                   and ! $test) {
   my $dialog = Gtk2::MessageDialog -> new ($window,
                                           'destroy-with-parent',
                                           'error',
                                           'close',
                                           "No scanners found");
   $dialog -> run;
   $dialog -> destroy;
  }
  else {

# scan pop-up window
   $windows = Gtk2::Window -> new;
   $windows -> set_border_width($border_width);
   $windows -> set_title ('Scan Document');
   $windows -> set_transient_for($window); # Assigns parent
   $windows -> signal_connect (delete_event => sub {
    $windows -> hide;
    return TRUE; # ensures that the window is not destroyed
   });

# VBox for window
   my $vbox = Gtk2::VBox -> new;
   $windows -> add ($vbox);

# HBox for devices
   my $hboxd = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxd, FALSE, FALSE, 0);

# device list
   my $labeld = Gtk2::Label -> new ("Device");
   $hboxd -> pack_start ($labeld, FALSE, FALSE, 0);

   my $optd = Gtk2::OptionMenu -> new;
   my $menud = Gtk2::Menu -> new;

# Need to define this here to reference it for later.
   my $vboxd = Gtk2::VBox -> new;

# parse out the device and model names
   my @device;
   if (! $test) {
    $output = `scanimage --formatted-device-list="'%i','%d','%v %m'
" 2>/dev/null`;

    my $device = substr($output, 0, index($output, "\n")+1);
    $output = substr($output, index($output, "\n")+1, length($output));
    while ($device =~ /'([0-9]*)','(.*)','(.*)'/) {
     $device[$1] = $2;

# Convert all underscores to spaces
     (my $model = $3) =~ s/_/ /g;
     $device = substr($output, 0, index($output, "\n")+1);
     $output = substr($output, index($output, "\n")+1, length($output));

# read the device names into the optionmenu
     my $item = Gtk2::MenuItem -> new ($model);
     $item -> signal_connect (activate => sub {
      update_options($vboxd, $device[$optd -> get_history]);
      $vboxd -> show_all;
     });
     $menud -> append ($item);
    }
   }
   else {
    my $item = Gtk2::MenuItem -> new (basename($test));
    $item -> signal_connect (activate => sub {
     update_options($vboxd, undef);
     $vboxd -> show_all;
    });
    $menud -> append ($item);
    push @device, basename($test);
   }
   $optd -> set_menu ($menud);
   $hboxd -> pack_end ($optd, FALSE, FALSE, 0);

# If device not set by config and there is a default device, then set it
   if (! defined($SETTING{"device"}) and $output =~ /default device is `(.*)'/) {
    $SETTING{"device"} = $1;
   }

# If device in settings then set it
   if (defined($SETTING{"device"})) {
    my $i = 0;
    ++$i while ($i <= $#device and $SETTING{"device"} ne $device[$i]);
    $optd -> set_history($i) if ($i <= $#device);
   }
   
# Frame for # pages
   my $framen = Gtk2::Frame -> new('# Pages');
   $vbox -> pack_start ($framen, FALSE, FALSE, 0);
   my $vboxn = Gtk2::VBox -> new;
   $vboxn -> set_border_width($border_width);
   $framen -> add ($vboxn);

#the first radio button has to set the group,
#which is undef for the first button
# All button
   my $buttona = Gtk2::RadioButton -> new(undef, "All");
   $vboxn -> pack_start($buttona, TRUE, TRUE, 0);
   my @groupn = $buttona -> get_group;

# Entry button
   my $hboxn = Gtk2::HBox -> new;
   $vboxn -> pack_start($hboxn, TRUE, TRUE, 0);
   my $buttone = Gtk2::RadioButton -> new(@groupn, "#:");
   $hboxn -> pack_start($buttone, FALSE, FALSE, 0);

# Number of pages
   my $spin_button = Gtk2::SpinButton -> new_with_range(1, 99, 1);
   $spin_button -> signal_connect ('value-changed' => sub {
    $buttone -> set_active(TRUE); # Set the radiobutton active
   });
   $hboxn -> pack_end ($spin_button, FALSE, FALSE, 0);

# Set default
   if (defined($SETTING{"pages to scan"})) {
    if ($SETTING{"pages to scan"} eq "all") {
     $buttona -> set_active(TRUE);
    }
    else {
     $buttone -> set_active(TRUE);
     $spin_button -> set_value($SETTING{"pages to scan"});
    }
   }
   else {
    $buttone -> set_active(TRUE);
   }

# Frame for source document
   my $frames = Gtk2::Frame -> new('Source document');
   $vbox -> pack_start ($frames, FALSE, FALSE, 0);
   my $vboxs = Gtk2::VBox -> new;
   $vboxs -> set_border_width($border_width);
   $frames -> add ($vboxs);

# Single sided button
   my $buttons = Gtk2::RadioButton -> new(undef, "Single sided");
   $vboxs -> pack_start($buttons, TRUE, TRUE, 0);
   $buttons -> set_active(TRUE);
   my @groups = $buttons -> get_group;

# Double sided button
   my $buttond = Gtk2::RadioButton -> new(@groups, "Double sided");
   $vboxs -> pack_start($buttond, FALSE, FALSE, 0);

# Facing/reverse page button
   my $hboxs = Gtk2::HBox -> new;
   $vboxs -> pack_start($hboxs, TRUE, TRUE, 0);
   my $labels = Gtk2::Label -> new ("Side to scan");
   $hboxs -> pack_start($labels, TRUE, TRUE, 0);

   my $opts = Gtk2::OptionMenu -> new;
   my $menus = Gtk2::Menu -> new;
   my @side = qw/Facing Reverse/;
   foreach (@side) {
    my $item = Gtk2::MenuItem -> new ($_);
    $item -> signal_connect ('activate' => sub {
     $buttond -> set_active(TRUE); # Set the radiobutton active
    });
    $menus -> append ($item);
   }
   $opts -> set_menu ($menus);
   $hboxs -> pack_end ($opts, FALSE, FALSE, 0);

# Frame for device-dependent options
   my $framed = Gtk2::Frame -> new('Device-dependent options');
   $vbox -> pack_start ($framed, FALSE, FALSE, 0);
   $vboxd -> set_border_width($border_width);
   $framed -> add ($vboxd);

# Dig the device-dependent options from --help --device-name
   if ($test) {
    update_options($vboxd, undef);
   }
   else {
    update_options($vboxd, $device[$optd -> get_history]);
   }

# HBox for buttons
   my $hboxb = Gtk2::HBox -> new;
   $vbox -> pack_end ($hboxb, FALSE, FALSE, 0);

# Scan button
   my $sbutton = Gtk2::Button -> new('Scan');
   $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
   $sbutton -> signal_connect (clicked => sub {

# Get selected device
    $SETTING{"device"} = $device[$optd -> get_history];
# inverted commas needed for strange characters in device name
    my $device = "--device-name='$SETTING{'device'}'";

# Get device-specific options
    my %options;
    my @child = $vboxd -> get_children;
    foreach my $hbox (@child) {
     my $key;
     if ($hbox -> isa('Gtk2::HBox')) {
      my @child = $hbox -> get_children;
      foreach my $widget (@child) {
       if ($widget -> isa('Gtk2::Label')) {
        $key = $widget -> get_label;
       }
       elsif ($widget -> isa('Gtk2::OptionMenu')) {
        my @child = $widget -> get_children;
        foreach my $widget (@child) {

# ignore artificial paper size option
         $SETTING{$key} = $widget -> get_label;
         if ($widget -> isa('Gtk2::Label') and $key ne 'Paper size') {
          $options{$key} = $SETTING{$key};
         }
        }
       }
       elsif ($widget -> isa('Gtk2::SpinButton')) {
        $options{$key} = $widget -> get_value;
        $SETTING{$key} = $options{$key};
       }
      }
     }
    }

# Get selected number of pages
    my $npages;
    if ($buttone -> get_active) {
     $SETTING{"pages to scan"} = $spin_button -> get_value;
     $npages = "--batch-count=$SETTING{'pages to scan'}";
    }
    else {
     $SETTING{"pages to scan"} = "all";
     $npages = "";
    }

# Start from next available page
    my $start;
    if ($#{$slist -> {data}} > -1) {
     $start = $slist -> {data}[$#{$slist -> {data}}][0] + 1;
    }
    else {
     $start = 1;
    }

# Set step according to single/double sided, facing/reverse page
    my $step;
    if ($buttond -> get_active) {
     if (($opts -> get_history) == 0) { # facing page
      $step = 2;
     }
     else { # reverse page
      if ($start == 1) {
       my $dialog = Gtk2::MessageDialog -> new ($windows,
        'destroy-with-parent',
        'error', # message type
        'cancel', # which set of buttons?
        "Must scan facing pages first");
       $dialog -> run;
       $dialog -> destroy;
       return 1;
      }

      $step = -2;

# Check that there is room in the list for the reverse pages
      my $i = 1;
      my $j = $#{$slist -> {data}};
      while ($slist->{data}[$j][0] != $start+$i*$step
             and $start+$i*$step > 0
             and $j > -1) {
       if ($slist->{data}[$j][0] > $start+$i*$step) {
        --$j;
       }
       else {
        ++$i;
       }
      }
      if ($buttone -> get_active) {
       if (($spin_button -> get_value) > $i) {
        my $dialog = Gtk2::MessageDialog -> new ($windows,
         'destroy-with-parent',
         'error', # message type
         'cancel', # which set of buttons?
         "Cannot scan more reverse pages\nthan facing pages");
        $dialog -> run;
        $dialog -> destroy;
        return 1;
       }
      }

# If user hasn't specified number of pages, then set number that is undefined
      else {
       $npages = "--batch-count=$i";
      }
     }
     $step = "--batch-increment=$step";
    }
    else {
     $step = "";
    }
    $start = "--batch-start=$start";
    scan($device, $npages, $start, $step, %options);
   } );

# Cancel button
   my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
   $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
   $cbutton -> signal_connect( clicked => sub { $windows -> hide; } );

   $windows -> show_all;
   if ($#paper > -1 or
       (defined($SETTING{"Paper size"}) and $SETTING{"Paper size"} ne "Custom")) {
    $hboxc -> hide;
    $windows -> resize(200, 200); # Doesn't matter that 200x200 is too small
   }
  }
 }
}


# Carry out the scan with the options passed.

sub scan {
 my ($device, $npages, $start, $step, %options) = @_;

# Basic options
 my @options = ( '--format=tiff',  
                 '--batch' );

# Add device-specific options
 my ($key, $value);
 while (($key, $value) = each(%options)) {
  if ($key eq 'x' or $key eq 'y') {
   push @options, "-$key $value";
  }
  else {
   push @options, "--$key=$value";
  }
 }

# Make sure we are in temp directory
 chdir $dir;

# Create command
 my $cmd = "scanimage $device $npages $start $step @options;echo 'End Scan' > /dev/stderr";

 if (! $test) {

# Interface to scanimage
  my ($write, $read);
  my $error = IO::Handle -> new; # this needed because of a bug in open3.
  my $pid = open3($write, $read, $error, $cmd);
  
  my $dialog = Gtk2::Dialog -> new ("Scanning...", $windows,
                                    'destroy-with-parent',
                                    'gtk-cancel' => 'cancel');
  my $label = Gtk2::Label -> new ("Scanning...");
  $dialog -> vbox -> add ($label);

# Ensure that the dialog box is destroyed when the user responds.
  $dialog -> signal_connect (response => sub {
   $_[0] -> destroy;
   local $SIG{HUP} = 'IGNORE';
   kill HUP => $pid;
  });
  $dialog -> show_all;
 
  my $line;
  Glib::IO -> add_watch(fileno($error), 'in', sub {
   my $buffer;
   sysread $error, $buffer, 1024;
   $line = $line . $buffer; # needed to cover case where line is broken in middle
   while ($line =~ /\n/) {
    if ($line =~ /^Scanning (-?[0-9]*) pages/) {
     $label -> set_text("Scanning $1 pages...");
    }
    elsif ($line =~ /^Scanning page ([0-9]*)/) {
     $label -> set_text("Scanning page $1...");
    }
    elsif ($line =~ /^Scanned page ([0-9]*)\. \(scanner status = 5\)/) {

# If the scan can't be loaded then blow the scanning dialog away and
# show an error
     if (! import_scan ("out$1.tif")) {
      $dialog -> destroy;
      $dialog = Gtk2::MessageDialog -> new ($windows, 'destroy-with-parent',
                        'error', 'close', 'Unable to load image');
      $dialog -> run;
      $dialog -> destroy;
      return 0;
     }
    }
    elsif ($line =~ /^End Scan/) {
     $dialog -> destroy;
     return 0; # Sascha Hunold [hunoldinho at users dot sourceforge dot net]
    }
    elsif ($line =~ /^Scanned page [0-9]*\. \(scanner status = 7\)/) {
     ;
    }
    elsif ($line =~ /^scanimage: sane_start: Document feeder out of documents/) {
     ;
    }
    else {
     $dialog -> destroy;
     my $text = "Unknown message: " . substr($line, 0, index($line, "\n"));
warn "$text\n";
     $dialog = Gtk2::MessageDialog -> new ($windows,
                                              'destroy-with-parent',
                                              'error',
                                              'close',
                                              $text);
     $dialog -> run;
     $dialog -> destroy;
     return 0;
    }
    $line = substr($line, index($line, "\n")+1, length($line));
   }
   return 1;
  });
 }
 else {
  warn "$cmd\n";
 }
}


# Take new scan and display it

sub import_scan {
 my ($ofilename) = @_;
 my (undef, $filename) = tempfile(DIR => $dir);
 system("mv $ofilename $filename");

# Need the eval otherwise nothing else in the sub gets carried out after an error
# For some reason reading the tiff sometimes throws:
# Failed to load RGB data from TIFF file:
#        libpixbuf-tiff: Read error on strip 134; got 5190 bytes, expected 7130
# Normally succeeds on second attempt
 my $src_pixbuf;
# Change new_from_file for new_from_file_at_scale once I no longer have to
# develop with Gtk2 < 1.090!
 eval { $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file ($filename); };
# if (Glib::Error::matches ($@, 'Mup::Thing::Error', 'flop')) {
#  recover_from_a_flop ();
# }
 if ($@) {
  warn "Warning: $@\n";
  eval { $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file ($filename); };
  if ($@) {
   return 0;
  }
  else {
   warn "Information: got $filename on second attempt\n";
  }
 }

# Get dimension for image
 my $widthi = $src_pixbuf -> get_width;
 my $heighti = $src_pixbuf -> get_height;

# Calculate scale factor for thumbnail, being conservative
 my $scale = ($widtht-1)/$widthi < ($heightt-1)/$heighti ? ($widtht-1)/$widthi : ($heightt-1)/$heighti;

 my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                        $src_pixbuf -> get_has_alpha, 
                                        $src_pixbuf -> get_bits_per_sample,
                                        $widthi*$scale, $heighti*$scale);
 zoom_pixbuf($src_pixbuf, $pixbuf, $scale);

# Add to the page list
 my $i;
 if ($ofilename =~ /out([0-9]*)\.tif/) {
  $i = $1;
 }
 else {
  $i = $#{$slist -> {data}}+2;
 }

# Block the row-changed signal whilst adding the scan (row) and sorting it.
 $slist -> get_model -> signal_handler_block($slist -> {signalid});
 push @{$slist -> {data}}, [$i, $pixbuf, $filename];
 manual_sort_by_column ($slist, 0);
 $slist -> get_model -> signal_handler_unblock($slist -> {signalid});

# Select new page, deselecting others. This fires the select callback,
# displaying the page
 $slist -> get_selection -> unselect_all;
 my @page;

# Due to the sort, must search for new page
 $page[0] = 0;
# $page[0] < $#{$slist -> {data}} needed to prevent infinite loop in case of
# error importing.
 ++$page[0] while ($page[0] < $#{$slist -> {data}}
                    and $slist -> {data}[$page[0]][0] != $i);

 $slist -> select(@page);
 return 1;
}


# Helpers:
sub compare_numeric_col { $_[0] <=> $_[1] }
sub compare_text_col { $_[0] cmp $_[1] }


# Manual one-time sorting of the simplelist's data

sub manual_sort_by_column {
 my ($slist, $sortcol) = @_;

# The sort function depends on the column type
 my %sortfuncs = ( 'Glib::Scalar' => \&compare_text_col,
                   'Glib::String' => \&compare_text_col,
                   'Glib::Int'    => \&compare_numeric_col,
                   'Glib::Double' => \&compare_numeric_col, );

# Remember, this relies on the fact that simplelist keeps model
# and view column indices aligned.
 my $sortfunc = $sortfuncs{$slist->get_model->get_column_type($sortcol)};

# Deep copy the tied data so we can sort it. Otherwise, very bad things happen.
 my @data = map { [ @$_ ] } @{ $slist->{data} };
 @data = sort { $sortfunc->($a->[$sortcol], $b->[$sortcol]) } @data;

 @{$slist->{data}} = @data;
}


# Delete the selected scans

sub delete_pages {
 my @page = $slist -> get_selected_indices;
 while ($#page > -1) {
  splice @{ $slist->{data} }, $page[0], 1;
  @page = $slist -> get_selected_indices;
 }
}


# Select all scans

sub select_all {
 $slist -> get_selection -> select_all;
}


# Display about dialog

sub about {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'info', 'ok', "$program v$version\n\n"
                     . "To aid the scan-to-PDF process.\n\n"
                     . "Copyright Jeff Ratcliffe\n"
                     . "Licensed under the GPLv2");
 $dialog -> run;
 $dialog -> destroy;
}


# Check that tiffcp & tiff2pdf exist

sub check_utils {
 system("which tiffcp >/dev/null 2>/dev/null");
 return $? if $? != 0;
 system("which tiff2pdf >/dev/null 2>/dev/null");
 return $? if $? != 0;
 return 0;
}


# Update device-dependent scan options

sub update_options {
 my ($vboxd, $device) = @_;

# Empty $vboxd first
 my @child = $vboxd -> get_children;
 foreach (@child) {
  $_ -> destroy;
 }

 my $output;
 if (defined($device)) {

# Get output from scanimage.
# Inverted commas needed for strange characters in device name
  $output = `scanimage --help --device-name='$device'`;
 }
 else {

# Slurp it from file
  $output = do { local( @ARGV, $/ ) = $test ; <> } ;
 }

# Skip to the device-specific options
 $output = substr($output, index($output, "Options specific to device"), length($output));
 $output = substr($output, index($output, "\n")+1, length($output));

# Dig out the paper sizes
 my ($x, $y);
 $x = $1 if ($output =~ /-x 0\.\.([0-9]*\.?[0-9]*)/);
 $y = $1 if ($output =~ /-y 0\.\.([0-9]*\.?[0-9]*)/);

 if (defined($x) and defined($y)) {

# HBox for paper size
  my $hboxp = Gtk2::HBox -> new;
  $vboxd -> pack_start ($hboxp, FALSE, FALSE, 0);

# Paper list
  my $labelp = Gtk2::Label -> new ("Paper size");
  $hboxp -> pack_start ($labelp, FALSE, FALSE, 0);

  my $optp = Gtk2::OptionMenu -> new;
  my $menup = Gtk2::Menu -> new;

# Define custom paper here to reference it in callback
  $hboxc = Gtk2::HBox -> new;
  my $spin_buttonx = Gtk2::SpinButton -> new_with_range(0, $x, 1);
  my $spin_buttony = Gtk2::SpinButton -> new_with_range(0, $y, 1);
  $tooltips -> set_tip ($spin_buttonx, 'Width of scan-area');
  $tooltips -> set_tip ($spin_buttony, 'Height of scan-area');

# Add paper size to optionmenu if scanner large enough
# can't use "for" because of the splices
  my $i = 0;
  while ($i <= $#paper) {
   if ($x >= $x[$i] and $y >= $y[$i]) {
    my $item = Gtk2::MenuItem -> new ($paper[$i]);
    $item -> signal_connect (activate => sub {
     my $i = $optp -> get_history;
     $spin_buttonx -> set_value($x[$i]);
     $spin_buttony -> set_value($y[$i]);
     $hboxc -> hide;
     $windows -> resize(200, 200); # Doesn't matter that 200x200 is too small
    });
    $menup -> append ($item);
    ++$i;
   }

# If the paper size isn't possible, remove it from the arrays
   else {
    splice @paper, $i, 1;
    splice @x, $i, 1;
    splice @y, $i, 1;
   }
  }

# Add custom option
  my $item = Gtk2::MenuItem -> new ('Custom');
  $item -> signal_connect (activate => sub { $hboxc -> show_all; });
  $menup -> append ($item);
  $optp -> set_menu ($menup);
  $hboxp -> pack_end ($optp, FALSE, FALSE, 0);

# Set default paper size from config
  if (defined($SETTING{"Paper size"})) {
   $i = 0;
   while ($i <= $#paper) {
    $optp -> set_history($i) if ($paper[$i] eq $SETTING{"Paper size"});
    ++$i;
   }
  }

# Set scan area from config if available
  if (defined($SETTING{"x"}) and defined($SETTING{"y"})) {
   $spin_buttonx -> set_value($SETTING{"x"});
   $spin_buttony -> set_value($SETTING{"y"});
  }

# Otherwise set from paper size if available
  elsif ($#paper > -1) {
   $i = $optp -> get_history;
   $spin_buttonx -> set_value($x[$i]);
   $spin_buttony -> set_value($y[$i]);
  }

# Or max available
  else {
   $spin_buttonx -> set_value($x);
   $spin_buttony -> set_value($y);
  }

  $vboxd -> pack_start ($hboxc, FALSE, FALSE, 0);

# custom paper x entry
  my $labelx = Gtk2::Label -> new ("x");
  $hboxc -> pack_start ($labelx, FALSE, FALSE, 0);
  $hboxc -> pack_start ($spin_buttonx, FALSE, FALSE, 0);

# custom paper y entry
  my $labely = Gtk2::Label -> new ("y");
  $hboxc -> pack_start ($labely, FALSE, FALSE, 0);
  $hboxc -> pack_start ($spin_buttony, FALSE, FALSE, 0);
 }

# Add remaining options
 while ($output =~ /--([a-z_-]*)(.*) \[(.*)\]/) {
  my $option = $1;
  my $values = $2;
  my $default = $3;
  $output = substr($output, index($output, "]\n")+2, length($output));

# Parse tooltips from option description based on an 8-character indent.
  my $tip = "";
  while ($output =~ /^\s{8,}(.*)/) {
   if ($tip eq "") {
    $tip = $1;
   }
   else {
    $tip = "$tip $1";
   }
   $output = substr($output, index($output, "\n")+1, length($output));
  }
# batch-scan is HP
# wait-for-button is Epson
# button-wait is HP
# source is various
  if ($option =~ /(^mode$|^resolution$|^batch-scan$|^wait-for-button$|^button-wait$|^source$)/
      and $default !~ /inactive/

# This needed for psc1315, that only has one option for source.
      and ($values =~ /([0-9]*\.?[0-9]*)\.\.([0-9]*\.?[0-9]*)/
       or $values =~ /\|/)) {

# Set default from config
   $default = $SETTING{$option} if (defined($SETTING{$option}));

# HBox for option
   my $hbox = Gtk2::HBox -> new;
   $vboxd -> pack_start ($hbox, TRUE, TRUE, 0);

# Label
   my $label = Gtk2::Label -> new ($option);
   $hbox -> pack_start ($label, FALSE, FALSE, 0);

# OptionMenu
   if ($values =~ /\|/) {
    my $opt = Gtk2::OptionMenu -> new;
    my $menu = Gtk2::Menu -> new;

# Counters for defaults
    my $i = -1;
    my $o;

# Parse items from output
    while ($values =~ /\|/) {
     my $value = substr($values, 0, index($values, "|"));
     $values = substr($values, index($values, "|")+1, length($values));
     $value = substr($value, 1, length($value)) while ($value =~ /^ /);
     $value = substr($value, 3, length($value)) while ($value =~ /^\[=\(/);

# Create item
     my $item = Gtk2::MenuItem -> new ($value);
     $menu -> append ($item);
     $i++;
     $o = $i if ($value eq $default);
    }

# Do it all again for the last one
    $values = substr($values, 0, length($values)-2) while ($values =~ /\)\]/);
    my $item = Gtk2::MenuItem -> new ($values);
    $menu -> append ($item);
    $i++;
    $o = $i if ($values eq $default);

# Create OptionMenu
    $opt -> set_menu ($menu);
    $opt -> set_history ($o) if defined($o);
    $hbox -> pack_end ($opt, FALSE, FALSE, 0);
    $tooltips -> set_tip ($opt, $tip);
   }

# SpinButton
   elsif ($values =~ /([0-9]*\.?[0-9]*)\.\.([0-9]*\.?[0-9]*)/) {
    my $spin_button = Gtk2::SpinButton -> new_with_range($1, $2, 1);
    $spin_button -> set_value($default);
    $hbox -> pack_end ($spin_button, FALSE, FALSE, 0);
    $tooltips -> set_tip ($spin_button, $tip);
   }
  }
 }
}


# Renumber pages

sub renumber {
 my ($slist, $column, $start, $step) = @_;

 $step = 1 if (! defined($step));

 if (defined($start)) {
  for (0 .. $#{$slist -> {data}}) {
   $slist -> {data}[$_][$column] = $_*$step + $start;
  }
 }

# If $start and $step are undefined, just make sure that the numbering is
# ascending.
 else {
  for (0 .. $#{$slist -> {data}}-1) {
   if ($slist -> {data}[$_+1][$column] <= $slist -> {data}[$_][$column]) {

# If at the beginning of the list, start from 1.
    if ($_ == 0) {
     $slist -> {data}[0][$column] = 1;
     $slist -> {data}[1][$column] = 2;
    }
    else {
     $slist -> {data}[$_][$column] = $slist -> {data}[$_-1][$column] + 1;
     $slist -> {data}[$_+1][$column] = $slist -> {data}[$_][$column] + 1
      if ($slist -> {data}[$_+1][$column] <= $slist -> {data}[$_][$column]);
    }
   }
  }
 }
}


# Remove temporary files, note window state, save settings and quit.

sub quit {

# Remove temporary files (for some reason File::Temp wasn't doing its job here)
 unlink <$dir/*>;
 rmdir $dir;

# Write window state to settings
 ($SETTING{"window_width"}, $SETTING{"window_height"}) = $window -> get_size;
 ($SETTING{"window_x"}, $SETTING{"window_y"}) = $window -> get_position;
 $SETTING{"thumb panel"} = $hpaned -> get_position;

# Write config file
 open (CONFIG, "> $config") or die "Can't open config file $config";
 while (my ($key, $value) = each %SETTING) {
  print CONFIG "$key = $value\n";
 }
 close CONFIG;
}


# View POD

sub view_pod {
 eval {require Gtk2::Ex::PodViewer;};
 if ($@) {
  my $dialog = Gtk2::MessageDialog -> new ($window,
                                          'destroy-with-parent',
                                          'error',
                                          'close',
                        "The help viewer requires module Gtk2::Ex::PodViewer\n"
                        ."Alternatively, try\n$program --help");
  $dialog -> run;
  $dialog -> destroy;
 }
 else {
#  use Gtk2::Ex::PodViewer;
#  use Gtk2::Ex::Simple::List;

# Window
  $windowh = Gtk2::Window -> new;
  $windowh -> set_transient_for($window); # Assigns parent
  $windowh -> signal_connect ( delete_event => sub {
   $windowh -> hide;
   return TRUE; # ensures that the window is not destroyed
  } );
  $windowh -> set_default_size (800, 600);

# Vertical divider between index and viewer
  my $pane = Gtk2::HPaned->new;
  $pane->set_position(200);
  $windowh -> add($pane);

# Index list
  my $index = Gtk2::SimpleList->new('icon' => 'pixbuf',
                                          'title' => 'text',
                                          'link' => 'filename');
  $index->set_headers_visible(FALSE);
  $index->get_column(1)->set_sizing('autosize');

# Index
  my $index_scrwin = Gtk2::ScrolledWindow->new;
  $index_scrwin->set_shadow_type('in');
  $index_scrwin->set_policy('automatic', 'automatic');
  $index_scrwin->add_with_viewport($index);
  $index_scrwin->get_child->set_shadow_type('none');

# Viewer
  my $viewer = Gtk2::Ex::PodViewer->new;
  $viewer->set_border_width($border_width);
  $viewer->set_cursor_visible(FALSE);
  $viewer->signal_connect(link_clicked => \&link_clicked);
  $viewer->signal_connect('link_enter', sub { set_status("Go to $_[1]") });
  $viewer->signal_connect('link_leave', sub { set_status('') });
  $index->get_selection->signal_connect('changed', sub {
   my $idx = ($index->get_selected_indices)[0];
   my $mark = $index->{data}[$idx][2];
   $viewer->jump_to($mark);
   return 1;
  });

  my $viewer_scrwin = Gtk2::ScrolledWindow->new;
  $viewer_scrwin->set_shadow_type('in');
  $viewer_scrwin->set_policy('automatic', 'automatic');
  $viewer_scrwin->add($viewer);

  $pane->add1($index_scrwin);
  $pane->add2($viewer_scrwin);

  $viewer -> load($0);

# Index contents
  my $idx_pbf = Gtk2::Image->new->render_icon('gtk-jump-to', 'menu');
  map { push(@{$index->{data}}, [ $idx_pbf, strippod ($_), $_ ]) }
                                                             $viewer->get_marks;

  $windowh -> show_all;
 }
}


# Remove formatting characters

sub strippod {
 my $text = shift;
 $text =~ s/B<([^<]*)>/$1/g;
 $text =~ s/E<gt>/>/g;
 $text
}


__END__

=head1 Name

gscan2pdf - A GUI to ease the process of producing PDFs from scanned documents

=head1 Synopsis

=over

=item 1. Scan one or several pages in with File/Scan

=item 2. Create PDF of selected pages with File/Save PDF

=back

=head1 Description

At maturity, the GUI will have similar features to that of the Windows Imaging program, but with the express objective of writing a PDF, including metadata.

Scanning is handled with SANE via scanimage.
PDF conversion is done by libtiff.

Perl is used for portability and ease of programming, with gtk2-perl for the GUI. This should therefore work more or less out of the box on any system with Perl, gtk2-perl, scanimage and libtiff.

=head1 Menus

=head2 File

=head3 New

Clears the page list.

=head3 Import

Imports a single or multipage TIFF.

=head3 Scan

Sets options before scanning via SANE.

=head4 Device

Chooses between available scanners.

=head4 # Pages

Selects the number of pages, or all pages to scan.

=head4 Source document

Selects between single sided or double sides pages.

This affects the page numbering. Single sided scans are numbered consecutively. Double sided scans are incremented (or decremented, see below) by 2, i.e. 1, 3, 5, etc..

=head4 Side to scan

If double sided is selected above, assuming a non-duplex scanner, i.e. a scanner that cannot automatically scan both sides of a page, this determines whether the page number is incremented or decremented by 2.

To scan both sides of three pages, i.e. 6 sides:

=over

=item 1. Select:
# Pages = 3 (or "all" if your scanner can detect when it is out of paper)

Double sided
Facing side

=item 2. Scans sides 1, 3 & 5.

=item 3. Put pile back with scanner ready to scan back of last page.

=item 4. Select:
# Pages = 3 (or "all" if your scanner can detect when it is out of paper)

Double sided
Reverse side

=item 5. Scans sides 6, 4 & 2.

=item 6. gscan2pdf automatically sorts the pages so that they appear in the correct order.

=back

=head4 Device-dependent options

These, naturally, depend on your scanner. They can include

=over

=item Page size.

=item Mode (colour/black & white/greyscale)

=item Resolution (in dpi)

=item Batch-scan
Guarantees that a "no documents" condition will be returned after the last scanned page, to prevent endless flatbed scans after a batch scan.

=item Wait-for-button/Button-wait
After sending the scan command, wait until the button on the scanner is pressed before actually starting the scan process.

=item Source
Selects the document source. Possible options can include Flatbed or ADF.

=back

=head3 Save PDF

Saves the current, selected or all pages as a PDF.

=head4 Metadata

Metadata are information that are not visible when viewing the PDF, but are embedded in the file and so searchable and can be examined, typically with the "Properties" option of the PDF viewer.

The metadata are completely optional.

=head3 Save TIFF

Saves the current, selected or all pages as a TIFF.

=head2 Edit

=head3 Delete

Deletes the selected page.

=head3 Renumber

Renumbers the pages from 1..n.

Note that the page order can also be changed by drag and drop in the thumnail view.

=head3 Select All

Selects all pages.

=head2 View

=head3 Zoom 100%

Zooms to 1:1. How this appears depends on the desktop resolution.

=head3 Zoom to fit

Scales the view such the all the page is visible.

=head3 Zoom in

=head3 Zoom out

=head1 FAQs

=head2 Why isn't option xyz available in the scan window?

Possibly because SANE or your scanner doesn't support it.

If an option listed in the output of

=over

=item scanimage --help

=back

that you would like to use isn't available, send me the output and I will look at implementing it.

=head1 See Also

Requires perl, libgtk2-perl (>=1.100-1), libglib-perl (>= 1.100-1), scanimage
and libtiff.

=head1 Author

Jeffrey Ratcliffe (ra28145 at users dot sourceforge dot net)

=cut
