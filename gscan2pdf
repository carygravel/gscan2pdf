#!/usr/bin/perl -w

# Copyright (c) 2006 by Jeff Ratcliffe (ra28145 at users dot sourceforge dot net)
# This script is released under the GPL license.  Please
# see the included LICENSE file for details.

# To do
# 0. Add renumber
#    Destroy window after pdf write
#    Destroy window after finished scanning single side
#    Hide windows rather than destroying them
#    Add status line at bottom with messages like "filename saved"
#    Add Gnome menu
#    Add batch/non-batch toggle and deal with non-ADF usage.
# 1. Reorder pages (DND)
# 2. Rotate
# 3. Read options from --help --device-name dev.
# 4. Add icons for import, save tiff, save pdf, quit, etc.
# 5. Add view menu matching zoom buttons
# 6. Get documentation up to scratch
# 7. Translations
# 8. Progress meter for scans and imports.

use strict;
use IPC::Open3;
use IO::Handle;
use Gtk2 -init;
use Gtk2::SimpleList;
use Cwd;                             # To obtain current working directory
use File::Temp qw/tempfile tempdir/; # To create temporary files

use constant TRUE  => 1;
use constant FALSE => 0;

my $program = "gscan2pdf";
my $version = 0.6;

if (check_utils()) {
 print "$program requires the libtiff library.\nPlease install it.\n";
 exit 1;
}

# This is the GtkItemFactoryEntry structure used to generate new menus.
# Item 1: The menu path. The letter after the underscore indicates an
#         accelerator key once the menu is open.
# Item 2: The accelerator key for the entry
# Item 3: The callback function.
# Item 4: The callback action.  This changes the parameters with
#         which the function is called.  The default is 0.
# Item 5: The item type, used to define what kind of an item it is.
#         Here are the possible values:
#          NULL               -> "<Item>"
#          ""                 -> "<Item>"
#          "<Title>"          -> create a title item
#          "<Item>"           -> create a simple item
#          "<CheckItem>"      -> create a check item
#          "<ToggleItem>"     -> create a toggle item
#          "<RadioItem>"      -> create a radio item
#          <path>             -> path of a radio item to link against
#          "<Separator>"      -> create a separator
#          "<Branch>"         -> create an item to hold sub items (optional)
#          "<LastBranch>"     -> create a right justified branch 

my @menu_items = ( { path        => '/_File',
		     item_type   => '<Branch>' },
		   { path        => '/File/_New',
		     accelerator => '<control>n',
		     callback    => \&do_new },
		   { path        => '/File/_Import',
		     accelerator => '<control>i',
		     callback    => \&do_import },
		   { path        => '/File/Sca_n',
		     callback    => \&scan_dialog },
		   { path        => '/File/_Save PDF',
		     accelerator => '<control>s',
		     callback    => \&do_PDF },
		   { path        => '/File/Save _TIFF',
		     accelerator => '<control>t',
		     callback    => \&do_TIFF },
		   { path        => '/File/sep1',
		     item_type   => '<Separator>' },
		   { path        => '/File/_Quit',
		     accelerator => '<control>q',
		     callback    => sub { Gtk2 -> main_quit; } },

		   { path        => '/_Edit',
		     item_type   => '<Branch>' },
		   { path        => '/Edit/_Delete',
		     accelerator => 'Delete',
		     callback    => \&do_delete },
		   { path        => '/Edit/Select _All',
		     accelerator => '<control>a',
		     callback    => \&do_select_all },

		   { path        => '/_Help',
		     item_type   => '<LastBranch>' },
		   { path        => '/_Help/About',
		     callback    => \&do_about } );

# Create the window
my $window = new Gtk2::Window ( 'toplevel' );
$window -> signal_connect ( 'destroy', sub { Gtk2 -> main_quit; } );
$window -> set_title ( "$program v$version" );
$window -> set_default_size (800, 600);
$window -> maximize;

# Pass the window a stock icon list
my @icon;
my $i = -1;
foreach my $size (qw/menu small-toolbar large-toolbar button dnd dialog/) {
 ++$i;
 $icon[$i] = $window -> render_icon ('gtk-print-preview', $size)
}
$window -> set_icon_list ( @icon );

my $main_vbox = new Gtk2::VBox ( FALSE, 1 );
$window -> add ( $main_vbox );

# Create the menu bar
my $menubar = create_menu_bar( $window );
$main_vbox -> pack_start( $menubar, FALSE, TRUE, 0 );

# Button bar
my $hboxb = Gtk2::HBox -> new;
$main_vbox -> pack_start ($hboxb, FALSE, FALSE, 0);
my $bbox = Gtk2::HButtonBox -> new;
$hboxb -> pack_start ($bbox, FALSE, FALSE, 0);

# Zoom to fullsize button
my $button1 = Gtk2::Button -> new_from_stock('gtk-zoom-100');
$button1 -> signal_connect(clicked => \&zoom_button);
$bbox -> add($button1);

# Zoom to fit button
my $buttonfit = Gtk2::Button -> new_from_stock('gtk-zoom-fit');
$buttonfit -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonfit);

# Zoom-in button
my $buttonin = Gtk2::Button -> new_from_stock('gtk-zoom-in');
$buttonin -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonin);

# Zoom-out button
my $buttonout = Gtk2::Button -> new_from_stock('gtk-zoom-out');
$buttonout -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonout);

# HPaned for thumbnails and detail view
my $hpaned = Gtk2::HPaned -> new;
$main_vbox -> pack_start($hpaned, TRUE, TRUE, 0);

# Thumbnail dimensions
my $widtht = 100;
my $heightt = 100;
$hpaned->set_position ($widtht);

# Scrolled window for thumbnails
my $scwin_thumbs = Gtk2::ScrolledWindow -> new;
$hpaned -> pack1 ($scwin_thumbs, TRUE, TRUE);
$scwin_thumbs -> set_policy ('automatic', 'automatic');

# define filename and i to be hidden
Gtk2::SimpleList -> add_column_type( 'filename',
                                     type => 'Glib::String',
                                     attr => 'hidden' );

# Set up a SimpleList, sorted by #2, which is hidden
my $list = Gtk2::SimpleList -> new('#' => 'int',
                                   'Thumbnails' => 'pixbuf',
                                   'Filename' => 'filename');
$list -> get_selection -> set_mode ('multiple');
$list -> get_model -> set_sort_column_id (0, 'ascending');
$scwin_thumbs -> add_with_viewport($list);

# Scrolled window for detail view
my $scwin_detail = Gtk2::ScrolledWindow -> new;
$hpaned -> pack2 ($scwin_detail, TRUE, TRUE);
$scwin_detail -> set_policy ('automatic', 'automatic');

# Globally define the $image variables for $scwin_detail
my $image;
my $scale;
my $src_pixbuf;
my $widthi;
my $heighti;

# Set up call back for list selection to update detail view
$list -> get_selection -> signal_connect(changed => sub {
 my @page = $list -> get_selected_indices;

# Remove any image in the detail window
 if (defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
 }

# Display the new image
 if ($#page > -1) {

# Get dimensions for detail window
  my $widthd = $scwin_detail -> allocation -> width;
  my $heightd = $scwin_detail -> allocation -> height;

  $image = Gtk2::Image -> new;

# scalar needed for reasons I don't understand, but which have to do with
# converting the array to a scalar. Alternatively, it might be a bug.
  $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file (scalar($list->{data}[$page[0]][2]));

# Get dimension for image
  $widthi = $src_pixbuf -> get_width;
  $heighti = $src_pixbuf -> get_height;

# Calculate scale factor to fit window, being conservative
  $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;

  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
});

# Note the current directory
my $cwd = getcwd;

# Create a temporary directory for scans
my $dir = tempdir;

$window -> show_all;
Gtk2 -> main;

# Remove temporary files (for some reason File::Temp wasn't doing its job here)
unlink <$dir/*>;
rmdir $dir;



### Subroutines

# Create the menu bar, initialize its menus, and return the menu bar.

sub create_menu_bar
{
 my ($window) = @_;

 my $accel_group = new Gtk2::AccelGroup;

 # This function initializes the item factory.
 # Param 1: The type of menu - can be 'Gtk2::MenuBar', 'Gtk2::Menu',
 #          or 'Gtk2::OptionMenu'.
 # Param 2: The path of the menu.
 # Param 3: The accelerator group.  The item factory sets up
 #          the accelerator table while generating menus.
 my $item_factory = new Gtk2::ItemFactory( 'Gtk2::MenuBar', '<main>',
                                                                 $accel_group );

 # This function generates the menu items. Pass the item factory,
 # the number of items in the array, the array itself, and any
 # callback data for the the menu items.
 $item_factory -> create_items( @menu_items );

 # Attach the new accelerator group to the window.
 $window -> add_accel_group( $accel_group );

 # Finally, return the actual menu bar created by the item factory.
 #*menubar = gtk_item_factory_get_widget (item_factory, "<main>");
 return ( $item_factory -> get_widget( '<main>' ) );
}


# Zoom the detail window

sub zoom_button {
 my $button = $_[0];
 if (defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
  if ($button eq $button1) {
   $scale = 1;
  }
  elsif ($button eq $buttonin) {
   $scale *= 1.2;
  }
  elsif ($button eq $buttonout) {
   $scale /= 1.2;
  }
  else {
   my $widthd = $scwin_detail -> allocation -> width;
   my $heightd = $scwin_detail -> allocation -> height;
   $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;
  }
  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
}


# Zoom the image

sub zoom_pixbuf {
 my ($src, $dest, $scale) = @_;
 $src -> composite ($dest, 0, 0, $dest -> get_width,
                                 $dest -> get_height, 
                    0, 0, $scale, $scale, 'bilinear', 255);
}


# Deletes all scans after warning.

sub do_new {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'warning', 'ok-cancel',
                     "This will clear the list of scanned images.\n"
                     . "Do you want to continue?");
 if ($dialog -> run eq 'ok') {

# Remove any image in the detail window
  if ($image) {
   my $viewport = $image -> get_parent;
   $image -> destroy;
   $viewport -> destroy;
  }

# Depopulate the thumbnail list
  while ($#{$list -> {data}} > -1) {
   pop @{$list -> {data}};
  }
 }
 $dialog -> destroy;
}


# Throw up file selector and import selected file

sub do_import {

# cd back to cwd to get filename
 chdir $cwd;

 my $fileselection = Gtk2::FileSelection -> new("Import scan from file");
 $fileselection -> set_modal(TRUE);
 $fileselection -> set_select_multiple(TRUE);

# cd back to tempdir to import
  chdir $dir;

# callback for OK button
 my $fs_ok_button = $fileselection -> ok_button;
 $fs_ok_button -> signal_connect(clicked => sub {

# Get filename(s) for PDF
  my @filename = $fileselection -> get_selections;

  $fileselection -> destroy;

  foreach my $filename (@filename) {

# Check that the file really is a tiff
   my $output = `tiffinfo \"$filename\" 2>&1 1>/dev/null`;
   if ($output =~ /Not a TIFF file/) {
    my $dialog = Gtk2::MessageDialog -> new ($window,
                                            'destroy-with-parent',
                                            'error',
                                            'close',
                                            "Not a TIFF file");
    $dialog -> run;
    $dialog -> destroy;
   }
   else {

# Split the tiff into its pages and import them individually
    system("tiffsplit \"$filename\"");
    my @pages = <x???.tif>;
    foreach (@pages) {
     import_scan($_);
    }
   }

  }
 });

# callback for cancel button
 my $fs_cancel_b = $fileselection -> cancel_button;
 $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

 $fileselection -> show_all;
}


# Throw up file selector and save selected pages as PDF under given name.

sub do_PDF {

# PDF pop-up window
 my $window = Gtk2::Window -> new;
 $window -> set_border_width(10);
 $window -> set_title ('Save as PDF');
 $window -> signal_connect (delete_event => sub { $_[0] -> destroy; });

# VBox for window
 my $vbox = Gtk2::VBox -> new;
 $window -> add ($vbox);

# Frame for metadata
 my $framem = Gtk2::Frame -> new('Metadata');
 $vbox -> pack_start ($framem, TRUE, TRUE, 0);
 my $vboxm = Gtk2::VBox -> new;
 $vboxm -> set_border_width(6);
 $framem -> add ($vboxm);

# Date/time
 my $hboxe = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxe, TRUE, TRUE, 0);
 my $labele = Gtk2::Label -> new ("Date & Time");
 $hboxe -> pack_start ($labele, FALSE, FALSE, 0);
 my ($day, $month, $year) = (localtime())[3, 4, 5];
 $year += 1900;
 $month += 1;
 my $buttone = Gtk2::Button -> new("$year/$month/$day");
 $buttone -> signal_connect( clicked => sub {
  my $window = Gtk2::Window -> new;
  $window -> set_title ('Select Date' );
  $window->set_border_width(5);
  $window->signal_connect( 'destroy' => sub { $window -> destroy; } );
  $window->set_resizable(FALSE);

  my $vbox = Gtk2::VBox -> new;
  $window -> add($vbox);

  my $calendar = Gtk2::Calendar -> new;
  $vbox -> pack_start ($calendar, TRUE, TRUE, 0);

  $calendar -> signal_connect(day_selected_double_click => sub {
   ($year, $month, $day) = $calendar -> get_date();
   $month += 1;
   $buttone -> set_label ("$year/$month/$day");
   $window -> destroy;
  });

  $window -> show_all;
 } );
 $hboxe -> pack_end( $buttone, TRUE, TRUE, 0 );

# Document author
 my $hboxa = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxa, TRUE, TRUE, 0);
 my $labela = Gtk2::Label -> new ("Document author");
 $hboxa -> pack_start ($labela, FALSE, FALSE, 0);
 my $entrya = Gtk2::Entry -> new;
 $hboxa -> pack_end( $entrya, TRUE, TRUE, 0 );

# Title
 my $hboxt = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxt, TRUE, TRUE, 0);
 my $labelt = Gtk2::Label -> new ("Title");
 $hboxt -> pack_start ($labelt, FALSE, FALSE, 0);
 my $entryt = Gtk2::Entry -> new;
 $hboxt -> pack_end( $entryt, TRUE, TRUE, 0 );

# Subject
 my $hboxs = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxs, TRUE, TRUE, 0);
 my $labels = Gtk2::Label -> new ("Subject");
 $hboxs -> pack_start ($labels, FALSE, FALSE, 0);
 my $entrys = Gtk2::Entry -> new;
 $hboxs -> pack_end( $entrys, TRUE, TRUE, 0 );

# Keywords
 my $hboxk = Gtk2::HBox -> new;
 $vboxm -> pack_start($hboxk, TRUE, TRUE, 0);
 my $labelk = Gtk2::Label -> new ("Keywords");
 $hboxk -> pack_start ($labelk, FALSE, FALSE, 0);
 my $entryk = Gtk2::Entry -> new;
 $hboxk -> pack_end( $entryk, TRUE, TRUE, 0 );

# Frame for page range
 my $framep = Gtk2::Frame -> new('Page range');
 $vbox -> pack_start ($framep, TRUE, TRUE, 0);
 my $vboxp = Gtk2::VBox -> new;
 $vboxp -> set_border_width(6);
 $framep -> add ($vboxp);

#the first radio button has to set the group,
#which is undef for the first button
# All button
 my $buttona = Gtk2::RadioButton -> new(undef, "All");
 $vboxp -> pack_start($buttona, TRUE, TRUE, 0);
 my @group = $buttona -> get_group;

# Current button
 my $buttonc = Gtk2::RadioButton -> new(@group, "Current");
 $vboxp -> pack_start($buttonc, TRUE, TRUE, 0);

# Selected button
 my $buttons = Gtk2::RadioButton -> new(@group, "Selected");
 $vboxp -> pack_start($buttons, TRUE, TRUE, 0);
 $buttons -> set_active(TRUE);

# Pages button
# my $hboxp = Gtk2::HBox -> new;
# $vboxp -> pack_start($hboxp, TRUE, TRUE, 0);
# my $buttonp = Gtk2::RadioButton -> new(@group, "Pages:");
# $hboxp -> pack_start($buttonp, FALSE, FALSE, 0);

# Page List
# my $entryp = Gtk2::Entry -> new;
# $entryp -> signal_connect ('insert-text' => sub {
#  my ($widget, $string, $len, $position) = @_;
#  if ($string !~ /^[0-9]+$/) { # Only add numbers
#   $entryp -> signal_stop_emission_by_name ('insert-text');
#   $buttonp -> set_active(TRUE); # Set the radiobutton active
#  }
#  () # this callback must return either 2 or 0 items.
# });
# $hboxp -> pack_end ($entryp, FALSE, FALSE, 0);

# HBox for filename
 my $hboxf = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxf, TRUE, TRUE, 0);

# Filename
 my $labelf = Gtk2::Label -> new ("Filename");
 $hboxf -> pack_start ($labelf, TRUE, TRUE, 0);
 my $entryf = Gtk2::Entry -> new;
 my $filename = "$cwd/out.pdf";
 $entryf -> set_text($filename);
 $hboxf -> add ($entryf);
 my $bbutton = Gtk2::Button -> new('Browse');
 $hboxf -> pack_end( $bbutton, TRUE, TRUE, 0 );
 $bbutton -> signal_connect (clicked => sub {

# cd back to cwd to save
  chdir $cwd;

# Set up file selector
  my $fileselection = Gtk2::FileSelection -> new("PDF filename");
  $fileselection -> set_modal(TRUE);
  my $fs_ok_button = $fileselection -> ok_button;

# callback for OK button
  $fs_ok_button -> signal_connect(clicked => sub {
   $filename = $fileselection -> get_filename;
   $entryf -> set_text($filename);
   $fileselection -> destroy;
  });

# callback for cancel button
  my $fs_cancel_b = $fileselection -> cancel_button;
  $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

  $fileselection -> show_all;

# cd back to tempdir
  chdir $dir;
 } );

# HBox for buttons
 my $hboxb = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Save button
 my $sbutton = Gtk2::Button -> new('Save');
 $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
 $sbutton -> signal_connect (clicked => sub {

# Get filename
  $filename = $entryf -> get_text;

# fill $pagelist with filenames depending on which radiobutton is active
  my $n;
  my $pagelist;
  if ($buttona -> get_active) {
   $n = $#{$list -> {data}};
   $pagelist = $list -> {data}[0][2];
   my $i = 1;
   while ($i <= $#{$list -> {data}}) {
    $pagelist = $pagelist." ".$list -> {data}[$i][2];
    ++$i;
   }
  }
  elsif ($buttonc -> get_active) {
   $n = 1;
   my @page = $list -> get_selected_indices;
   $pagelist = $list -> {data}[$page[0]][2];
  }
  elsif ($buttons -> get_active) {
   my @page = $list -> get_selected_indices;
   $n = $#page;
   $pagelist = $list -> {data}[$page[0]][2];
   my $i = 1;
   while ($i <= $#page) {
    $pagelist = $pagelist." ".$list -> {data}[$page[$i]][2];
    ++$i;
   }
  }

# Set options and metadata
  my $options = " -z -o \"$filename\""
              . sprintf (" -e %4i%02i%02i", $year, $month, $day)
              . " -c \"$program v$version\""
              . " -a \"" . $entrya -> get_text . "\""
              . " -t \"" . $entryt -> get_text . "\""
              . " -s \"" . $entrys -> get_text . "\""
              . " -k \"" . $entryk -> get_text . "\"";

# call tiff2pdf and/or tiffcp according to the number of pages
  if ($n > 0) {
   system ("tiffcp $pagelist \"$filename.tif\"");
   system ("tiff2pdf \"$filename.tif\" $options");
   unlink ("$filename.tif"); # delete the temporary tiff
  }
  else {
   system ("tiff2pdf $pagelist $options");
  }
 } );

# Cancel button
 my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
 $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
 $cbutton -> signal_connect( clicked => sub { $window -> destroy; } );

 $window -> show_all;
}


# Throw up file selector and save selected pages as PDF under given name.

sub do_TIFF {

# PDF pop-up window
 my $window = Gtk2::Window -> new;
 $window -> set_border_width(10);
 $window -> set_title ('Save as TIFF');
 $window -> signal_connect (delete_event => sub { $_[0] -> destroy; });

# VBox for window
 my $vbox = Gtk2::VBox -> new;
 $window -> add ($vbox);

# Frame for page range
 my $framep = Gtk2::Frame -> new('Page range');
 $vbox -> pack_start ($framep, TRUE, TRUE, 0);
 my $vboxp = Gtk2::VBox -> new;
 $vboxp -> set_border_width(6);
 $framep -> add ($vboxp);

#the first radio button has to set the group,
#which is undef for the first button
# All button
 my $buttona = Gtk2::RadioButton -> new(undef, "All");
 $vboxp -> pack_start($buttona, TRUE, TRUE, 0);
 my @group = $buttona -> get_group;

# Current button
 my $buttonc = Gtk2::RadioButton -> new(@group, "Current");
 $vboxp -> pack_start($buttonc, TRUE, TRUE, 0);

# Selected button
 my $buttons = Gtk2::RadioButton -> new(@group, "Selected");
 $vboxp -> pack_start($buttons, TRUE, TRUE, 0);
 $buttons -> set_active(TRUE);

# HBox for filename
 my $hboxf = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxf, TRUE, TRUE, 0);

# Filename
 my $labelf = Gtk2::Label -> new ("Filename");
 $hboxf -> pack_start ($labelf, TRUE, TRUE, 0);
 my $entryf = Gtk2::Entry -> new;
 my $filename = "$cwd/out.tif";
 $entryf -> set_text($filename);
 $hboxf -> add ($entryf);
 my $bbutton = Gtk2::Button -> new('Browse');
 $hboxf -> pack_end( $bbutton, TRUE, TRUE, 0 );
 $bbutton -> signal_connect (clicked => sub {

# cd back to cwd to save
  chdir $cwd;

# Set up file selector
  my $fileselection = Gtk2::FileSelection -> new("TIFF filename");
  $fileselection -> set_modal(TRUE);
  my $fs_ok_button = $fileselection -> ok_button;

# callback for OK button
  $fs_ok_button -> signal_connect(clicked => sub {
   $filename = $fileselection -> get_filename;
   $entryf -> set_text($filename);
   $fileselection -> destroy;
  });

# callback for cancel button
  my $fs_cancel_b = $fileselection -> cancel_button;
  $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

  $fileselection -> show_all;

# cd back to tempdir
  chdir $dir;
 } );

# HBox for buttons
 my $hboxb = Gtk2::HBox -> new;
 $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Save button
 my $sbutton = Gtk2::Button -> new('Save');
 $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
 $sbutton -> signal_connect (clicked => sub {

# Get filename
  $filename = $entryf -> get_text;

# fill $pagelist with filenames depending on which radiobutton is active
  my $n;
  my $pagelist;
  if ($buttona -> get_active) {
   $n = $#{$list -> {data}};
   $pagelist = $list -> {data}[0][2];
   my $i = 1;
   while ($i <= $#{$list -> {data}}) {
    $pagelist = $pagelist." ".$list -> {data}[$i][2];
    ++$i;
   }
  }
  elsif ($buttonc -> get_active) {
   $n = 1;
   my @page = $list -> get_selected_indices;
   $pagelist = $list -> {data}[$page[0]][2];
  }
  elsif ($buttons -> get_active) {
   my @page = $list -> get_selected_indices;
   $n = $#page;
   $pagelist = $list -> {data}[$page[0]][2];
   my $i = 1;
   while ($i <= $#page) {
    $pagelist = $pagelist." ".$list -> {data}[$page[$i]][2];
    ++$i;
   }
  }

# Create the tiff
  system ("tiffcp $pagelist \"$filename\"");

  $window -> destroy;
 } );

# Cancel button
 my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
 $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
 $cbutton -> signal_connect( clicked => sub { $window -> destroy; } );

 $window -> show_all;
}


# Scan

sub scan_dialog {
 my $output = `scanimage --version 2>/dev/null`;
 if ($? ne 0) {
  my $dialog = Gtk2::MessageDialog -> new ($window,
                                          'destroy-with-parent',
                                          'error',
                                          'close',
                                          "scanimage not found");
  $dialog -> run;
  $dialog -> destroy;
  return 0;
 }
 my @output = `scanimage --list-devices 2>/dev/null`;
 if ($? eq 0) {
  if ($#output > 1 && $output[0] =~ /^\s$/ 
                   && $output[1] =~ /^No scanners were identified/) {
   my $dialog = Gtk2::MessageDialog -> new ($window,
                                           'destroy-with-parent',
                                           'error',
                                           'close',
                                           "No scanners found");
   $dialog -> run;
   $dialog -> destroy;
  }
  else {

# scan pop-up window
   my $window = Gtk2::Window -> new;
   $window -> set_border_width(10);
   $window -> set_title ('Scan Document');
   $window -> signal_connect (delete_event => sub { $_[0] -> destroy; });

# VBox for window
   my $vbox = Gtk2::VBox -> new;
   $window -> add ($vbox);

# HBox for devices
   my $hboxd = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxd, TRUE, TRUE, 0);

# device list
   my $labeld = Gtk2::Label -> new ("Device");
   $hboxd -> pack_start ($labeld, FALSE, FALSE, 0);

   my $optd = Gtk2::OptionMenu -> new;
   my $menud = Gtk2::Menu -> new;

# parse out the device and model names
   my $output = `scanimage --formatted-device-list="%i %d.%v %m;" 2>/dev/null`;

   my @device;
   my $device = substr($output, 0, index($output, ";")+1);
   $output = substr($output, index($output, ";")+1, length($output));
   while ($device =~ /([0-9]*) (.*)\.(.*);/) {
    $device[$1] = $2;

# Convert all underscores to spaces
    (my $model = $3) =~ s/_/ /g;
    $device = substr($output, 0, index($output, ";")+1);
    $output = substr($output, index($output, ";")+1, length($output));

# read the device names into the optionmenu
    my $item = Gtk2::MenuItem -> new ($model);
    $menud -> append ($item);
   }
   $optd -> set_menu ($menud);
   $hboxd -> pack_end ($optd, FALSE, FALSE, 0);

# If there is a default device, then set it
   if ($output =~ /default device is `(.*)'/) {
    my $i = 0;
    ++$i while ($1 ne $device[$i]);
    $optd -> set_history($i);
   }
   
# HBox for paper size
   my $hboxp = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxp, TRUE, TRUE, 0);

# Paper list
   my $labelp = Gtk2::Label -> new ("Paper size");
   $hboxp -> pack_start ($labelp, FALSE, FALSE, 0);

   my $optp = Gtk2::OptionMenu -> new;
   my $menup = Gtk2::Menu -> new;
   foreach (qw/A4 Letter Custom/) {
    my $item = Gtk2::MenuItem -> new ($_);
#    $item -> signal_connect (activate => \&activate, $_);
    $menup -> append ($item);
   }
   $optp -> set_menu ($menup);
   $hboxp -> pack_end ($optp, FALSE, FALSE, 0);

# HBox for custom paper
   my $hboxc = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxc, TRUE, TRUE, 0);

# custom paper x entry
   my $labelx = Gtk2::Label -> new ("x");
   $hboxc -> pack_start ($labelx, FALSE, FALSE, 0);

   my $entryx = Gtk2::Entry -> new;
   $entryx -> set_text("210");
   $entryx -> set_width_chars(4);
   $entryx -> signal_connect ('insert-text' => sub {
    my ($widget, $string, $len, $position) = @_;
    if ($string !~ /^[0-9]+$/) { # Only add numbers
     $entryx -> signal_stop_emission_by_name ('insert-text');
    }
    () # this callback must return either 2 or 0 items.
   });
   $hboxc -> pack_start ($entryx, FALSE, FALSE, 0);

# custom paper y entry
   my $labely = Gtk2::Label -> new ("y");
   $hboxc -> pack_start ($labely, FALSE, FALSE, 0);

   my $entryy = Gtk2::Entry -> new;
   $entryy -> set_text("297");
   $entryy -> set_width_chars(4);
   $entryy -> signal_connect ('insert-text' => sub {
    my ($widget, $string, $len, $position) = @_;
    if ($string !~ /^[0-9]+$/) { # Only add numbers
     $entryy -> signal_stop_emission_by_name ('insert-text');
    }
    () # this callback must return either 2 or 0 items.
   });
   $hboxc -> pack_start ($entryy, FALSE, FALSE, 0);

# HBox for mode
   my $hboxm = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxm, TRUE, TRUE, 0);

# Mode list
   my $labelm = Gtk2::Label -> new ("Mode");
   $hboxm -> pack_start ($labelm, FALSE, FALSE, 0);

   my $optm = Gtk2::OptionMenu -> new;
   my $menum = Gtk2::Menu -> new;
   my @mode = qw/Lineart Gray Color/;
   foreach (@mode) {
    my $item = Gtk2::MenuItem -> new ($_);
    $menum -> append ($item);
   }
   $optm -> set_menu ($menum);
   $hboxm -> pack_end ($optm, FALSE, FALSE, 0);

# HBox for resolution
   my $hboxr = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxr, TRUE, TRUE, 0);

# resolution entry
   my $labelr = Gtk2::Label -> new ("Resolution");
   $hboxr -> pack_start ($labelr, FALSE, FALSE, 0);

   my $entryr = Gtk2::Entry -> new;
   $entryr -> set_text("300");
   $entryr -> set_width_chars(4);
   $entryr -> signal_connect ('insert-text' => sub {
    my ($widget, $string, $len, $position) = @_;
    if ($string !~ /^[0-9]+$/) { # Only add numbers
     $entryr -> signal_stop_emission_by_name ('insert-text');
    }
    () # this callback must return either 2 or 0 items.
   });
   $hboxr -> pack_end ($entryr, FALSE, FALSE, 0);

# Frame for # pages
   my $framen = Gtk2::Frame -> new('# Pages');
   $vbox -> pack_start ($framen, TRUE, TRUE, 0);
   my $vboxn = Gtk2::VBox -> new;
   $vboxn -> set_border_width(6);
   $framen -> add ($vboxn);

#the first radio button has to set the group,
#which is undef for the first button
# All button
   my $buttona = Gtk2::RadioButton -> new(undef, "All");
   $vboxn -> pack_start($buttona, TRUE, TRUE, 0);
   $buttona -> set_active(TRUE);
   my @groupn = $buttona -> get_group;

# Entry button
   my $hboxn = Gtk2::HBox -> new;
   $vboxn -> pack_start($hboxn, TRUE, TRUE, 0);
   my $buttone = Gtk2::RadioButton -> new(@groupn, "#:");
   $hboxn -> pack_start($buttone, FALSE, FALSE, 0);

# Number of pages
   my $spin_button = Gtk2::SpinButton -> new_with_range(1, 99, 1);
   $spin_button -> signal_connect ('value-changed' => sub {
    $buttone -> set_active(TRUE); # Set the radiobutton active
   });
   $hboxn -> pack_end ($spin_button, FALSE, FALSE, 0);

# Frame for source document
   my $frames = Gtk2::Frame -> new('Source document');
   $vbox -> pack_start ($frames, TRUE, TRUE, 0);
   my $vboxs = Gtk2::VBox -> new;
   $vboxs -> set_border_width(6);
   $frames -> add ($vboxs);

# Single sided button
   my $buttons = Gtk2::RadioButton -> new(undef, "Single sided");
   $vboxs -> pack_start($buttons, TRUE, TRUE, 0);
   $buttons -> set_active(TRUE);
   my @groups = $buttons -> get_group;

# Double sided button
   my $buttond = Gtk2::RadioButton -> new(@groups, "Double sided");
   $vboxs -> pack_start($buttond, FALSE, FALSE, 0);

# Facing/reverse page button
   my $hboxs = Gtk2::HBox -> new;
   $vboxs -> pack_start($hboxs, TRUE, TRUE, 0);
   my $labels = Gtk2::Label -> new ("Side to scan");
   $hboxs -> pack_start($labels, TRUE, TRUE, 0);

   my $opts = Gtk2::OptionMenu -> new;
   my $menus = Gtk2::Menu -> new;
   my @side = qw/Facing Reverse/;
   foreach (@side) {
    my $item = Gtk2::MenuItem -> new ($_);
    $item -> signal_connect ('activate' => sub {
     $buttond -> set_active(TRUE); # Set the radiobutton active
    });
    $menus -> append ($item);
   }
   $opts -> set_menu ($menus);
   $hboxs -> pack_end ($opts, FALSE, FALSE, 0);

# HBox for buttons
   my $hboxb = Gtk2::HBox -> new;
#   $vbox -> add ($hboxb);
   $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Scan button
   my $sbutton = Gtk2::Button -> new('Scan');
   $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
   $sbutton -> signal_connect (clicked => sub {

# Get selected device
    $device = "--device-name=".$device[$optd -> get_history];

# Get selected paper size
    my @paper = ( '-x 210 -y 297', '-x 216 -y 279' );
    my $paper;
    if (($optp -> get_history) > $#paper) {
     $paper = "-x ".$entryx -> get_text." -y ".$entryy -> get_text;
    }
    else {
     $paper = $paper[$optp -> get_history];
    }

# Get selected mode
    my $mode = "--mode=".$mode[$optm -> get_history];

# Get selected resolution
    my $resolution = "--resolution ".$entryr -> get_text;

# Get selected number of pages
    my $npages;
    if ($buttone -> get_active) {
     $npages = "--batch-count ".$spin_button -> get_value;
    }
    else {
     $npages = "";
    }

# Start from next available page
    my $start;
    if ($#{$list -> {data}} > -1) {
     $start = $list -> {data}[$#{$list -> {data}}][0] + 1;
    }
    else {
     $start = 1;
    }

# Set step according to single/double sided, facing/reverse page
    my $step;
    if ($buttond -> get_active) {
     if (($opts -> get_history) == 0) { # facing page
      $step = 2;
     }
     else { # reverse page
      if ($start == 1) {
       my $dialog = Gtk2::MessageDialog -> new ($window,
        'destroy-with-parent',
        'error', # message type
        'cancel', # which set of buttons?
        "Must scan facing pages first");
       $dialog -> run;
       $dialog -> destroy;
       return 1;
      }

      $step = -2;

# Check that there is room in the list for the reverse pages
      my $i = 1;
      my $j = $#{$list -> {data}};
      while ($list->{data}[$j][0] != $start+$i*$step
             && $start+$i*$step > 0
             && $j > -1) {
       if ($list->{data}[$j][0] > $start+$i*$step) {
        --$j;
       }
       else {
        ++$i;
       }
      }
      if ($buttone -> get_active) {
       if (($spin_button -> get_value) > $i) {
        my $dialog = Gtk2::MessageDialog -> new ($window,
         'destroy-with-parent',
         'error', # message type
         'cancel', # which set of buttons?
         "Cannot scan more reverse pages\nthan facing pages");
        $dialog -> run;
        $dialog -> destroy;
        return 1;
       }
      }

# If user hasn't specified number of pages, then set number that is undefined
      else {
       $npages = "--batch-count ".$i;
      }
     }
     $step = "--batch-increment=".$step;
    }
    else {
     $step = "";
    }
    $start = "--batch-start=".$start;
    do_scan($device, $paper, $mode, $resolution, $npages, $start, $step);
   } );

# Cancel button
   my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
   $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
   $cbutton -> signal_connect( clicked => sub { $window -> destroy; } );

   $window -> show_all;
  }
 }
}


# Callback for paper size option menu

#sub activate {
# my ($widget, $data) = @_;
# if ($data eq 'Custom') {
#  $hboxc -> show_all;
# }
# else {
#  $hboxc -> hide_all;
# }
#}


# Carry out the scan with the options passed.

sub do_scan {
 my ($device, $paper, $mode, $resolution, $npages, $start, $step) = @_;

 my @options = ( '--format=tiff',  
                 '--batch-scan=yes',  
                 '--batch' );
 my $cmd = "scanimage $device $paper $mode $resolution $npages $start $step @options;echo 'End Scan' > /dev/stderr";

# Interface to scanimage
 my ($write, $read);
 my $error = IO::Handle -> new; # this needed because of a bug in open3.
 my $pid = open3($write, $read, $error, $cmd);
 
 my $dialog = Gtk2::Dialog -> new ("Scanning...", $window,
                                   'destroy-with-parent',
                                   'gtk-cancel' => 'cancel');
 my $label = Gtk2::Label -> new ("Scanning...");
 $dialog -> vbox -> add ($label);

# Ensure that the dialog box is destroyed when the user responds.
 $dialog -> signal_connect (response => sub {
  $_[0] -> destroy;
  local $SIG{HUP} = 'IGNORE';
  kill HUP => $pid;
 });
 $dialog -> show_all;
 
 my $line;
 Glib::IO -> add_watch(fileno($error), 'in', sub {
  my $buffer;
  sysread $error, $buffer, 1024;
  $line = $line . $buffer; # needed to cover case where line is broken in middle
  while ($line =~ /\n/) {
   if ($line =~ /^Scanning (-?[0-9]*) pages/) {
    $label -> set_text("Scanning $1 pages...");
   }
   elsif ($line =~ /^Scanning page ([0-9]*)/) {
    $label -> set_text("Scanning page $1...");
   }
   elsif ($line =~ /^Scanned page ([0-9]*)\. \(scanner status = 5\)/) {
    import_scan ("out$1.tif");
   }
   elsif ($line =~ /^End Scan/) {
    $dialog -> destroy;
   }
   else {
    $label -> set_text("Unknown message: " . substr($line, 0, index($line, "\n")));
   }
   $line = substr($line, index($line, "\n")+1, length($line));
  }
  return 1;
 });
}


# Take new scan and display it

sub import_scan {
 my ($ofilename) = @_;
 my (undef, $filename) = tempfile(DIR => $dir);
 system("mv $ofilename $filename");

 my $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file ($filename);

# Get dimension for image
 my $widthi = $src_pixbuf -> get_width;
 my $heighti = $src_pixbuf -> get_height;

# Calculate scale factor for thumbnail, being conservative
 my $scale = ($widtht-1)/$widthi < ($heightt-1)/$heighti ? ($widtht-1)/$widthi : ($heightt-1)/$heighti;

 my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                        $src_pixbuf -> get_has_alpha, 
                                        $src_pixbuf -> get_bits_per_sample,
                                        $widthi*$scale, $heighti*$scale);
 zoom_pixbuf($src_pixbuf, $pixbuf, $scale);

# Add to the page list
 my $i;
 if ($ofilename =~ /out([0-9]*)\.tif/) {
  $i = $1;
 }
 else {
  $i = $#{$list -> {data}}+2;
 }
 push @{$list -> {data}}, [$i, $pixbuf, $filename];

# Select new page, deselecting others. This fires the select callback,
# displaying the page
 $list -> get_selection -> unselect_all;
 my @page;

# Due to the sort, must search for new page
 $page[0] = 0;
 ++$page[0] while ($list -> {data}[$page[0]][0] != $i);

 $list -> select(@page);
}


# Delete the selected scans

sub do_delete {
 my @page = $list -> get_selected_indices;
 while ($#page > -1) {
  splice @{ $list->{data} }, $page[0], 1;
  @page = $list -> get_selected_indices;
 }
}


# Select all scans

sub do_select_all {
 $list -> get_selection -> select_all;
}


# Display about dialog

sub do_about {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'info', 'ok', "$program v$version\n\n"
                     . "To aid the scan-to-PDF process.\n\n"
                     . "Copyright Jeff Ratcliffe\n"
                     . "Licensed under the GPLv2");
 $dialog -> run;
 $dialog -> destroy;
}


# Check that tiffcp & tiff2pdf exist

sub check_utils {
 system("which tiffcp >/dev/null 2>/dev/null");
 return $? if $? != 0;
 system("which tiff2pdf >/dev/null 2>/dev/null");
 return $? if $? != 0;
 return 0;
}

__END__

=head1 NAME

gscan2pdf - A GUI to ease the process of producing PDFs from scanned documents

=head1 SYNOPSIS

1. Scan one or several pages in with File/Scan
2. Create PDF of selected pages with File/Save PDF

=head1 DESCRIPTION

At maturity, the GUI will have similar features to that of the Windows Imaging
program, but with the express objective of writing a PDF, including metadata.

Scanning is handled with SANE via scanimage.
PDF conversion is done by libtiff.

Perl is used for portability and ease of programming, with gtk2-perl for the
GUI. This should therefore work more or less out of the box on any system with
Perl, gtk2-perl, scanimage and libtiff.

=head1 SEE ALSO

Requires perl, libgtk2-perl (>=1.100-1), libglib-perl (>= 1.100-1), scanimage
and libtiff.

=head1 AUTHOR

Jeffrey Ratcliffe

=cut
