#!/usr/bin/perl -w

# Copyright (c) 2006 by Jeff Ratcliffe (ra28145 at users dot sourceforge dot net)
# This script is released under the GPL license.  Please
# see the included LICENSE file for details.

# To do
# 0. cd to temp directory & keep note of last page number, using appropriate --batch-start command to prevent overwrites.
#    work out how to create a .deb for it, or at least an install script.
#    Add batch/non-batch toggle and deal with non-ADF usage.
# 1. Delete single/multiple pages
# 2. Metadata in PDF
# 3. Icon for program
# 4. Multiselect tiffs to import
# 5. Double-sided
# 6. Reorder pages
# 7. Add save as tiff
# 8. Import multi-page tiffs
# 9. Rotate

use strict;
use IPC::Open3;
use IO::Handle;
use Gtk2 -init;
use Gtk2::SimpleList;
use File::Temp qw/tempfile tempdir/; # To create temporary files

use constant TRUE  => 1;
use constant FALSE => 0;

my $program = "gscan2pdf";
my $version = 0.4;

if (check_utils() ne 0) {
 print "$program requires libtiff (tiffcp & tiff2pdf).\nPlease install them.\n";
 exit 1;
}

# This is the GtkItemFactoryEntry structure used to generate new menus.
# Item 1: The menu path. The letter after the underscore indicates an
#         accelerator key once the menu is open.
# Item 2: The accelerator key for the entry
# Item 3: The callback function.
# Item 4: The callback action.  This changes the parameters with
#         which the function is called.  The default is 0.
# Item 5: The item type, used to define what kind of an item it is.
#         Here are the possible values:
#          NULL               -> "<Item>"
#          ""                 -> "<Item>"
#          "<Title>"          -> create a title item
#          "<Item>"           -> create a simple item
#          "<CheckItem>"      -> create a check item
#          "<ToggleItem>"     -> create a toggle item
#          "<RadioItem>"      -> create a radio item
#          <path>             -> path of a radio item to link against
#          "<Separator>"      -> create a separator
#          "<Branch>"         -> create an item to hold sub items (optional)
#          "<LastBranch>"     -> create a right justified branch 

my @menu_items = ( { path        => '/_File',
		     item_type   => '<Branch>' },
		   { path        => '/File/_New',
		     accelerator => '<control>n',
		     callback    => \&do_new },
		   { path        => '/File/_Import',
		     accelerator => '<control>i',
		     callback    => \&do_import },
		   { path        => '/File/Sca_n',
		     callback    => \&scan_dialog },
		   { path        => '/File/_Save PDF',
		     accelerator => '<control>s',
		     callback    => \&do_save },
		   { path        => '/File/sep1',
		     item_type   => '<Separator>' },
		   { path        => '/File/_Quit',
		     accelerator => '<control>q',
		     callback    => sub { Gtk2 -> main_quit; } },

#		   { path        => '/_Edit',
#		     item_type   => '<Branch>' },
#		   { path        => '/Edit/Delete',
#		     accelerator => '<delete>',
#		     callback    => \&do_delete },
#		   { path        => '/Edit/Mark _All',
#		     accelerator => '<control>a',
#		     callback    => \&do_mark },

		   { path        => '/_Help',
		     item_type   => '<LastBranch>' },
		   { path        => '/_Help/About',
		     callback    => \&do_about } );

# Create the window
my $window = new Gtk2::Window ( 'toplevel' );
#$window -> set_icon_from_stock ( 'gtk-print-preview' );
$window -> signal_connect ( 'destroy', sub { Gtk2 -> main_quit; } );
$window -> set_title ( "$program v$version" );
$window -> set_default_size (800, 600);
$window -> maximize;

my $main_vbox = new Gtk2::VBox ( FALSE, 1 );
$window -> add ( $main_vbox );

# Create the menu bar
my $menubar = create_menu_bar( $window );
$main_vbox -> pack_start( $menubar, FALSE, TRUE, 0 );

# Button bar
my $hboxb = Gtk2::HBox -> new;
$main_vbox -> pack_start ($hboxb, FALSE, FALSE, 0);
my $bbox = Gtk2::HButtonBox -> new;
$hboxb -> pack_start ($bbox, FALSE, FALSE, 0);

# Zoom to fullsize button
my $button1 = Gtk2::Button -> new_from_stock('gtk-zoom-100');
$button1 -> signal_connect(clicked => \&zoom_button);
$bbox -> add($button1);

# Zoom to fit button
my $buttonfit = Gtk2::Button -> new_from_stock('gtk-zoom-fit');
$buttonfit -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonfit);

# Zoom-in button
my $buttonin = Gtk2::Button -> new_from_stock('gtk-zoom-in');
$buttonin -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonin);

# Zoom-out button
my $buttonout = Gtk2::Button -> new_from_stock('gtk-zoom-out');
$buttonout -> signal_connect(clicked => \&zoom_button);
$bbox -> add($buttonout);

# HPaned for thumbnails and detail view
my $hpaned = Gtk2::HPaned -> new;
$main_vbox -> pack_start($hpaned, TRUE, TRUE, 0);

# Thumbnail dimensions
my $widtht = 100;
my $heightt = 100;
$hpaned->set_position ($widtht);

# Scrolled window for thumbnails
my $scwin_thumbs = Gtk2::ScrolledWindow -> new;
$hpaned -> pack1 ($scwin_thumbs, TRUE, TRUE);
$scwin_thumbs -> set_policy ('automatic', 'automatic');
my $list = Gtk2::SimpleList -> new('Thumbnails' => 'pixbuf');
$list -> get_selection -> set_mode ('multiple');
$scwin_thumbs -> add_with_viewport($list);

# Store the list of filenames for the thumbnails in parallel list
my @filename;

# Scrolled window for detail view
my $scwin_detail = Gtk2::ScrolledWindow -> new;
$hpaned -> pack2 ($scwin_detail, TRUE, TRUE);
$scwin_detail -> set_policy ('automatic', 'automatic');

# Globally define the $image variables for $scwin_detail
my $image;
my $scale;
my $src_pixbuf;
my $widthi;
my $heighti;

# Set up call back for list selection to update detail view
$list -> get_selection -> signal_connect(changed => sub {
 my @page = $list -> get_selected_indices;

# Remove any image in the detail window
 if (defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
 }

# Display the new image
 if ($#page > -1) {

# Get dimensions for detail window
  my $widthd = $scwin_detail -> allocation -> width;
  my $heightd = $scwin_detail -> allocation -> height;

  $image = Gtk2::Image -> new;

# scalar needed for reasons I don't understand, but which have to do with
# converting the array to a scalar. Alternatively, it might be a bug.
  $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file (scalar($filename[$page[0]]));

# Get dimension for image
  $widthi = $src_pixbuf -> get_width;
  $heighti = $src_pixbuf -> get_height;

# Calculate scale factor to fit window, being conservative
  $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;

  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
});

$window -> show_all;
Gtk2 -> main;



### Subroutines

# Create the menu bar, initialize its menus, and return the menu bar.

sub create_menu_bar
{
 my ($window) = @_;

 my $accel_group = new Gtk2::AccelGroup;

 # This function initializes the item factory.
 # Param 1: The type of menu - can be 'Gtk2::MenuBar', 'Gtk2::Menu',
 #          or 'Gtk2::OptionMenu'.
 # Param 2: The path of the menu.
 # Param 3: The accelerator group.  The item factory sets up
 #          the accelerator table while generating menus.
 my $item_factory = new Gtk2::ItemFactory( 'Gtk2::MenuBar', '<main>',
                                                                 $accel_group );

 # This function generates the menu items. Pass the item factory,
 # the number of items in the array, the array itself, and any
 # callback data for the the menu items.
 $item_factory -> create_items( @menu_items );

 # Attach the new accelerator group to the window.
 $window -> add_accel_group( $accel_group );

 # Finally, return the actual menu bar created by the item factory.
 #*menubar = gtk_item_factory_get_widget (item_factory, "<main>");
 return ( $item_factory -> get_widget( '<main>' ) );
}


# Zoom the detail window

sub zoom_button {
 my $button = $_[0];
 if (defined($scwin_detail -> child)) {
  my $viewport = $image -> get_parent;
  $image -> destroy;
  $viewport -> destroy;
  if ($button eq $button1) {
   $scale = 1;
  }
  elsif ($button eq $buttonin) {
   $scale *= 1.2;
  }
  elsif ($button eq $buttonout) {
   $scale /= 1.2;
  }
  else {
   my $widthd = $scwin_detail -> allocation -> width;
   my $heightd = $scwin_detail -> allocation -> height;
   $scale = ($widthd-1)/$widthi < ($heightd-1)/$heighti ? ($widthd-1)/$widthi : ($heightd-1)/$heighti;
  }
  my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                         $src_pixbuf -> get_has_alpha, 
                                         $src_pixbuf -> get_bits_per_sample,
                                         $widthi*$scale, $heighti*$scale);
  zoom_pixbuf($src_pixbuf, $pixbuf, $scale);
  $image -> set_from_pixbuf($pixbuf);

  $scwin_detail -> add_with_viewport($image);
  $scwin_detail -> show_all;
 }
}


# Zoom the image

sub zoom_pixbuf {
 my ($src, $dest, $scale) = @_;
 $src -> composite ($dest, 0, 0, $dest -> get_width,
                                 $dest -> get_height, 
                    0, 0, $scale, $scale, 'bilinear', 255);
}


# Deletes all scans after warning.

sub do_new {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'warning', 'ok-cancel',
                     "This will clear the list of scanned images.\n"
                     . "Do you want to continue?");
 if ($dialog -> run eq 'ok') {

# Remove any image in the detail window
  if ($image) {
   my $viewport = $image -> get_parent;
   $image -> destroy;
   $viewport -> destroy;
  }

# Depopulate the thumbnail list
  while ($#{$list -> {data}} > -1) {
   pop @{$list -> {data}};
   pop @filename;
  }
 }
 $dialog -> destroy;
}


# Throw up file selector and import selected file

sub do_import {
 my $fileselection = Gtk2::FileSelection -> new("Import scan from file");
 $fileselection -> set_modal(TRUE);

# callback for OK button
 my $fs_ok_button = $fileselection -> ok_button;
 $fs_ok_button -> signal_connect(clicked => sub {

# Get filename for PDF
  my $filename = $fileselection -> get_filename;
  $fileselection -> destroy;
  import_scan($filename);
 });

# callback for cancel button
 my $fs_cancel_b = $fileselection -> cancel_button;
 $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

 $fileselection -> show_all;
}


# Throw up file selector and save selected pages as PDF under given name.

sub do_save {
# Set up file selector
 my $fileselection = Gtk2::FileSelection -> new("Save PDF");
 $fileselection -> set_modal(TRUE);
 my $fs_ok_button = $fileselection -> ok_button;

# callback for OK button
 $fs_ok_button -> signal_connect(clicked => sub {
  my $filename = $fileselection -> get_filename;
  $fileselection -> destroy;

# fill $pagelist with filenames of selected pages
  my @page = $list -> get_selected_indices;
  my $pagelist = $filename[$page[0]];
  my $i = 1;
  while ($i <= $#page) {
   $pagelist = $pagelist." ".$filename[$page[$i]];
   ++$i;
  }

# call tiff2pdf and/or tiffcp according to the number of pages
  if ($#page > 0) {
   system ("tiffcp $pagelist \"$filename.tif\"");
   system ("tiff2pdf -z \"$filename.tif\" -o \"$filename\"");
   unlink ("$filename.tif"); # delete the temporary tiff
  }
  else {
   system ("tiff2pdf -z $pagelist -o \"$filename\"");
  }
 });

# callback for cancel button
 my $fs_cancel_b = $fileselection -> cancel_button;
 $fs_cancel_b -> signal_connect(clicked => sub{ $fileselection -> destroy; });

 $fileselection -> show_all;
}


# Scan

sub scan_dialog {
 my $output = `scanimage --version 2>/dev/null`;
 if ($? ne 0) {
  my $dialog = Gtk2::MessageDialog -> new ($window,
                                          'destroy-with-parent',
                                          'error',
                                          'close',
                                          "scanimage not found");
  $dialog -> run;
  $dialog -> destroy;
  return 0;
 }
 my @output = `scanimage --list-devices 2>/dev/null`;
 if ($? eq 0) {
  if ($#output > 1 && $output[0] =~ /^\s$/ 
                   && $output[1] =~ /^No scanners were identified/) {
   my $dialog = Gtk2::MessageDialog -> new ($window,
                                           'destroy-with-parent',
                                           'error',
                                           'close',
                                           "No scanners found");
   $dialog -> run;
   $dialog -> destroy;
  }
  else {

# scan pop-up window
   my $window = Gtk2::Window -> new;
   $window -> set_border_width(10);
   $window -> set_title ('Scan Document');
   $window -> signal_connect (delete_event => sub { $_[0] -> destroy; });

# VBox for window
   my $vbox = Gtk2::VBox -> new;
   $window -> add ($vbox);

# HBox for devices
   my $hboxd = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxd, TRUE, TRUE, 0);

# device list
   my $labeld = Gtk2::Label -> new ("Device");
   $hboxd -> pack_start ($labeld, FALSE, FALSE, 0);

   my $optd = Gtk2::OptionMenu -> new;
   my $menud = Gtk2::Menu -> new;

# parse out the device and model names
   my $output = `scanimage --formatted-device-list="%i %d.%v %m;" 2>/dev/null`;

   my @device;
   my $device = substr($output, 0, index($output, ";")+1);
   $output = substr($output, index($output, ";")+1, length($output));
   while ($device =~ /([0-9]*) (.*)\.(.*);/) {
    $device[$1] = $2;

# Convert all underscores to spaces
    (my $model = $3) =~ s/_/ /g;
    $device = substr($output, 0, index($output, ";")+1);
    $output = substr($output, index($output, ";")+1, length($output));

# read the device names into the optionmenu
    my $item = Gtk2::MenuItem -> new ($model);
    $item -> show;
    $menud -> append ($item);
   }
   $optd -> set_menu ($menud);
   $hboxd -> pack_end ($optd, FALSE, FALSE, 0);
   
# HBox for paper size
   my $hboxp = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxp, TRUE, TRUE, 0);

# Paper list
   my $labelp = Gtk2::Label -> new ("Paper size");
   $hboxp -> pack_start ($labelp, FALSE, FALSE, 0);

   my $optp = Gtk2::OptionMenu -> new;
   my $menup = Gtk2::Menu -> new;
   foreach (qw/A4 Letter Custom/) {
    my $item = Gtk2::MenuItem -> new ($_);
    $item -> show;
#    $item -> signal_connect (activate => \&activate, $_);
    $menup -> append ($item);
   }
   $optp -> set_menu ($menup);
   $hboxp -> pack_end ($optp, FALSE, FALSE, 0);

# HBox for custom paper
   my $hboxc = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxc, TRUE, TRUE, 0);

# custom paper x entry
   my $labelx = Gtk2::Label -> new ("x");
   $hboxc -> pack_start ($labelx, FALSE, FALSE, 0);

   my $entryx = Gtk2::Entry -> new;
   $entryx -> set_text("210");
   $entryx -> signal_connect ('insert-text' => sub {
    my ($widget, $string, $len, $position) = @_;
    if ($string !~ /^[0-9]+$/) { # Only add numbers
     $entryx -> signal_stop_emission_by_name ('insert-text');
    }
    () # this callback must return either 2 or 0 items.
   });
   $hboxc -> pack_start ($entryx, FALSE, FALSE, 0);

# custom paper y entry
   my $labely = Gtk2::Label -> new ("y");
   $hboxc -> pack_start ($labely, FALSE, FALSE, 0);

   my $entryy = Gtk2::Entry -> new;
   $entryy -> set_text("297");
   $entryy -> signal_connect ('insert-text' => sub {
    my ($widget, $string, $len, $position) = @_;
    if ($string !~ /^[0-9]+$/) { # Only add numbers
     $entryy -> signal_stop_emission_by_name ('insert-text');
    }
    () # this callback must return either 2 or 0 items.
   });
   $hboxc -> pack_start ($entryy, FALSE, FALSE, 0);

# HBox for mode
   my $hboxm = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxm, TRUE, TRUE, 0);

# Mode list
   my $labelm = Gtk2::Label -> new ("Mode");
   $hboxm -> pack_start ($labelm, FALSE, FALSE, 0);

   my $optm = Gtk2::OptionMenu -> new;
   my $menum = Gtk2::Menu -> new;
   my @mode = qw/Lineart Gray Color/;
   foreach (@mode) {
    my $item = Gtk2::MenuItem -> new ($_);
    $item -> show;
    $menum -> append ($item);
   }
   $optm -> set_menu ($menum);
   $hboxm -> pack_end ($optm, FALSE, FALSE, 0);

# HBox for resolution
   my $hboxr = Gtk2::HBox -> new;
   $vbox -> pack_start ($hboxr, TRUE, TRUE, 0);

# resolution entry
   my $labelr = Gtk2::Label -> new ("Resolution");
   $hboxr -> pack_start ($labelr, FALSE, FALSE, 0);

   my $entryr = Gtk2::Entry -> new;
   $entryr -> set_text("300");
   $entryr -> signal_connect ('insert-text' => sub {
    my ($widget, $string, $len, $position) = @_;
    if ($string !~ /^[0-9]+$/) { # Only add numbers
     $entryr -> signal_stop_emission_by_name ('insert-text');
    }
    () # this callback must return either 2 or 0 items.
   });
   $hboxr -> pack_end ($entryr, FALSE, FALSE, 0);

# Frame for # pages
   my $frame = Gtk2::Frame -> new('# Pages');
   $vbox -> pack_start ($frame, TRUE, TRUE, 0);
   my $vboxn = Gtk2::VBox -> new;
   $vboxn -> set_border_width(6);
   $frame -> add ($vboxn);

#the first radio button has to set the group,
#which is undef for the first button
# All button
   my $buttona = Gtk2::RadioButton -> new(undef, "All");
   $vboxn -> pack_start($buttona, TRUE, TRUE, 0);
   $buttona -> set_active(TRUE);
   $buttona -> show;
   my @group = $buttona -> get_group;

# Entry button
   my $hboxn = Gtk2::HBox -> new;
   $vboxn -> pack_start($hboxn, TRUE, TRUE, 0);
   my $buttone = Gtk2::RadioButton -> new(@group);
   $hboxn -> pack_start($buttone, FALSE, FALSE, 0);
   $buttone -> show;

# Number of pages
   my $entryn = Gtk2::Entry -> new;
   $entryn -> signal_connect ('insert-text' => sub {
    my ($widget, $string, $len, $position) = @_;
    if ($string !~ /^[0-9]+$/) { # Only add numbers
     $entryn -> signal_stop_emission_by_name ('insert-text');
     $buttone -> set_active(TRUE); # Set the radiobutton active
    }
    () # this callback must return either 2 or 0 items.
   });
   $hboxn -> pack_end ($entryn, FALSE, FALSE, 0);

# HBox for buttons
   my $hboxb = Gtk2::HBox -> new;
#   $vbox -> add ($hboxb);
   $vbox -> pack_start ($hboxb, TRUE, TRUE, 0);

# Scan button
   my $sbutton = Gtk2::Button -> new('Scan');
   $hboxb -> pack_start( $sbutton, TRUE, TRUE, 0 );
   $sbutton -> signal_connect (clicked => sub {
    $device = "--device-name=".$device[$optd -> get_history];
    my @paper = ( '-x 210 -y 297', '-x 216 -y 279' );
    my $paper;
    if (($optp -> get_history) > $#paper) {
     $paper = "-x ".$entryx -> get_text." -y ".$entryy -> get_text;
    }
    else {
     $paper = $paper[$optp -> get_history];
    }
    my $mode = "--mode=".$mode[$optm -> get_history];
    my $resolution = "--resolution ".$entryr -> get_text;
    my $npages;
    if ($buttone -> get_active) {
     $npages = "--batch-count ".$entryn -> get_text;
    }
    else {
     $npages = "";
    }
    do_scan($device, $paper, $mode, $resolution, $npages);
   } );

# Cancel button
   my $cbutton = Gtk2::Button -> new_from_stock('gtk-cancel');
   $hboxb -> pack_end( $cbutton, FALSE, FALSE, 0 );
   $cbutton -> signal_connect( clicked => sub { $window -> destroy; } );

   $window -> show_all;
  }
 }
}


# Callback for paper size option menu

#sub activate {
# my ($widget, $data) = @_;
# if ($data eq 'Custom') {
#  $hboxc -> show_all;
# }
# else {
#  $hboxc -> hide_all;
# }
#}


# Carry out the scan with the options passed.

sub do_scan {
 my ($device, $paper, $mode, $resolution, $npages) = @_;

 my @options = ( '--format=tiff',  
                 '--batch' );
 my $cmd = "scanimage $device $paper $mode $resolution $npages @options;echo 'End Scan' > /dev/stderr";

# Interface to scanimage
 my ($write, $read);
 my $error = IO::Handle -> new; # this needed because of a bug in open3.
 my $pid = open3($write, $read, $error, $cmd);
# waitpid($pid, 0); # A non-blocking wait for the PID to finish to prevent zombies
# only it blocks, unfortunately
 
 my $dialog = Gtk2::Dialog -> new ("Scanning...", $window,
                                   'destroy-with-parent',
                                   'gtk-cancel' => 'cancel');
 my $label = Gtk2::Label -> new ("Scanning...");
 $dialog -> vbox -> add ($label);

# Ensure that the dialog box is destroyed when the user responds.
 $dialog -> signal_connect (response => sub {
  $_[0] -> destroy;
  local $SIG{HUP} = 'IGNORE';
  kill HUP => $pid;
 });
 $dialog -> show_all;
 
 my $line;
 Glib::IO -> add_watch(fileno($error), 'in', sub {
  my $buffer;
  sysread $error, $buffer, 1024;
  $line = $line . $buffer; # needed to cover case where line is broken in middle
  while ($line =~ /\n/) {
   my $scanned;
   if ($line =~ /Scanning ([0-9]*) pages/) {
    $label -> set_text("Scanning $1 pages...");
    $scanned = TRUE;
   }
   elsif ($line =~ /Scanning page ([0-9]*)/) {
    $label -> set_text("Scanning page $1...");
    $scanned = TRUE;
   }
   elsif ($line =~ /Scanned page ([0-9]*)\. \(scanner status = 5\)/) {
    import_scan ("out$1.tif");
    $scanned = TRUE;
   }
   elsif ($line =~ /End Scan/) {
    $dialog -> destroy;
   }
   else {
    $label -> set_text("Unknown message: " . substr($line, 0, index($line, '\n')));
   }
   $line = substr($line, index($line, "\n")+1, length($line));
  }
  return 1;
 });
}


# Take new scan and display it

sub import_scan {
 my ($filename) = @_;

 my $src_pixbuf = Gtk2::Gdk::Pixbuf -> new_from_file ($filename);

# Get dimension for image
 my $widthi = $src_pixbuf -> get_width;
 my $heighti = $src_pixbuf -> get_height;

# Calculate scale factor for thumbnail, being conservative
 my $scale = ($widtht-1)/$widthi < ($heightt-1)/$heighti ? ($widtht-1)/$widthi : ($heightt-1)/$heighti;

 my $pixbuf = Gtk2::Gdk::Pixbuf -> new ($src_pixbuf -> get_colorspace,
                                        $src_pixbuf -> get_has_alpha, 
                                        $src_pixbuf -> get_bits_per_sample,
                                        $widthi*$scale, $heighti*$scale);
 zoom_pixbuf($src_pixbuf, $pixbuf, $scale);

# Add to the page list
 push @{$list -> {data}}, [$pixbuf];
 push @filename, $filename;

# Select new page, deselecting others. This fires the select callback,
# displaying the page
 $list -> get_selection -> unselect_all;
 my @page;
 $page[0] = $#{$list -> {data}};
 $list -> select(@page);

 $scwin_thumbs -> show_all;
}


# Display about dialog

sub do_about {
 my $dialog = Gtk2::MessageDialog -> new ($window, 'destroy-with-parent',
                     'info', 'ok', "$program v$version\n\n"
                     . "To aid the scan-to-PDF process.\n\n"
                     . "Copyright Jeff Ratcliffe\n"
                     . "Licensed under the GPLv2");
 $dialog -> run;
 $dialog -> destroy;
}


# Check that tiffcp & tiff2pdf exist

sub check_utils {
 system("which tiffcp >/dev/null 2>/dev/null");
 return $? if $? != 0;
 system("which tiff2pdf >/dev/null 2>/dev/null");
 return $? if $? != 0;
 return 0;
}

__END__

=head1 NAME

gscan2pdf - A GUI to ease the process of producing PDFs from scanned documents

=head1 SYNOPSIS

1. Scan one or several pages in with File/Scan
2. Select pages as you wish
3. Create PDF of selected pages with File/Save PDF

=head1 DESCRIPTION

At maturity, the GUI will have similar features to that of the Windows Imaging program, but with the express objective of writing a PDF, including metadata.

Scanning is handled with SANE via scanimage.
PDF conversion is done by libtiff.

Perl is used for portability and ease of programming, with gtk2-perl for the GUI. This should therefore work more or less out of the box on any system with Perl, gtk2-perl, scanimage and libtiff.

=head1 SEE ALSO

Requires perl, libgtk2-perl (>=1.100-1), libglib-perl (>= 1.100-1), scanimage and libtiff.

=head1 AUTHOR

Jeffrey Ratcliffe

=cut
